[{"content":" GPIO 子系统：管电平（高低/输入输出）。 Pinctrl 子系统：管模式（这个脚是作 GPIO 用，还是作 I2C 用？）和特性（上拉、下拉、驱动能力）。 在 RK3568 这种复杂的 SoC 上，Pinctrl 尤为重要。我将结合你提供的目录结构，为你拆解这个子系统。\n📂 相关文件 # 想要有能力自己分析问题，你必须知道代码在哪。对于 RK3568：\nPinctrl 核心框架（Linux 官方写的，也就是教程里分析的通用的部分）：\n路径：drivers/pinctrl/core.c (核心逻辑) 路径：drivers/pinctrl/pinmux.c (复用逻辑) 路径：drivers/pinctrl/pinconf.c (配置逻辑) 作用：制定标准，提供 pinctrl_register 等 API。 RK3568 平台驱动（Rockchip 厂家写的，负责操作硬件寄存器）：\n路径：drivers/pinctrl/pinctrl-rockchip.c 作用：这是最重要的文件！它读取 DTS，解析 RK 特有的属性，并真正去写 RK3568 的硬件寄存器。 设备树配置（我们修改的地方）：\n路径：arch/arm64/boot/dts/rockchip/rk3568-pinctrl.dtsi 作用：定义了 RK3568 所有引脚的预设配置。 🗺️ 第一部分：Pinctrl 子系统在讲什么？（全局观） # 想象 RK3568 是一个拥有几百个引脚的“瑞士军刀”。同一个引脚（比如 GPIO0_B7），既可以是普通的刀片（GPIO），也可以是剪刀（PWM），还可以是螺丝刀（UART）。\nPinctrl 子系统就是那个“选择机构”：\n复用（Muxing）：决定把这个引脚连到芯片内部的哪个模块（GPIO 控制器？PWM 控制器？）。 配置（Conf）：决定这个引脚的电气属性（上拉、下拉、驱动电流大小）。 ⚙️ 第三部分：概念与源码对应（硬核知识通俗化） # 对应你的目录第 123-126 章，这里有很多结构体，我们用通俗语言对应代码。\n1. Pin, Group 和 Function # Pin (引脚)：芯片上最基本的物理焊盘。 Group (引脚组)：有时一个功能需要多个引脚（比如 UART 需要 TX 和 RX）。这几个引脚这就叫一个 Group。 Function (功能)：这个 Group 要干什么？是做 \u0026ldquo;uart\u0026rdquo; 还是做 \u0026ldquo;gpio\u0026rdquo;？ 在代码中（pinctrl-rockchip.c）： 厂家驱动里会定义一堆数组，把物理引脚编号和名字对应起来。\n2. 核心结构体：pinctrl_map # 这是最关键的概念。Map（映射） 就像是一个“订单”。 当我们在设备树里写下配置时，内核会把它解析成一张张 map。\nMap 包含什么？ 设备名：谁要用这个引脚？（比如 \u0026amp;uart1） 状态名：这是什么状态下的配置？（比如 default 或 sleep） 控制类型：是复用（MUX）还是配置（CONFIG）？ 3. 从 DTS 到 Map：dt_node_to_map # 这是驱动初始化的核心流程。 函数位置：drivers/pinctrl/pinctrl-rockchip.c 中的 rockchip_dt_node_to_map。\n流程解析：\n内核启动，解析设备树。 遇到 Pinctrl 节点。 调用 dt_node_to_map。 这个函数会把 DTS 里的 \u0026lt;\u0026amp;gpio0 RK_PB7 RK_FUNC_GPIO \u0026amp;pcfg_pull_up\u0026gt; 解析出来，生成内核能看懂的配置表。 dt_node_to_map函数详细讲解 # 个人感觉只需知道是干嘛的就行，细节可以等学完再抠。 简单来说，rockchip_dt_node_to_map 是一个“翻译官”。\n它的工作是：将 Rockchip 驱动内部自定义的 Group（引脚组）结构体，转换成 Linux Pinctrl 子系统通用的 Map（映射）结构体。\n我们结合你提供的代码和 RK3568 的 DTS 实例，把这几行代码像剥洋葱一样拆解开来。\n0. 核心背景：数据从哪来？ # 在分析代码前，必须先明白一个隐藏的前提。 在这个函数被调用之前，Rockchip 的驱动（pinctrl-rockchip.c）其实已经干了一件大事：预解析。\n驱动在初始化时，已经扫描了设备树里的 rockchip,pins 属性，把每一个 pinctrl 节点（比如 i2c0_xfer）解析成了一个 rockchip_pin_group 结构体，存放在 info 里了。\ngrp (Rockchip 内部结构)：已经存好了“这个组有哪些引脚”、“每个引脚要配什么电平”。 map (Linux 通用结构)：是这个函数要生成的目标。 1. 代码逐行拆解与实战映射 # 假设我们的 DTS 是这样的（I2C0 的例子）：\n/* rk3568-pinctrl.dtsi */ \u0026amp;pinctrl { /* 父节点：代表 Function (功能) */ i2c0 { /* 子节点：代表 Group (组) */ i2c0_xfer: i2c0-xfer { /* 具体的配置数据 */ rockchip,pins = /* 0号控制器, PB1引脚, 功能1(I2C), 无上拉 */ \u0026lt;0 RK_PB1 1 \u0026amp;pcfg_pull_none\u0026gt;, /* 0号控制器, PB2引脚, 功能1(I2C), 无上拉 */ \u0026lt;0 RK_PB2 1 \u0026amp;pcfg_pull_none\u0026gt;; }; }; }; 现在内核要解析 i2c0_xfer 这个节点，传入的参数 np 就是 i2c0-xfer 的节点指针。\n第一步：找到对应的 Group (查户口) # /* 通过节点名字，在已加载的驱动数据中找到对应的 group 结构体 */ grp = pinctrl_name_to_group(info, np-\u0026gt;name); if (!grp) { // ... 报错 ... return -EINVAL; } 解析：np-\u0026gt;name 是 \u0026quot;i2c0-xfer\u0026quot;。驱动在之前已经把这个名字注册过一遍了。这里就是通过名字把之前解析好的数据（包含那是哪几个引脚、配置值是多少）拿出来，赋值给 grp。 此时 grp 里有什么： grp-\u0026gt;name: \u0026ldquo;i2c0-xfer\u0026rdquo; grp-\u0026gt;npins: 2 (因为 rockchip,pins 里写了两行) grp-\u0026gt;pins: [GPIO0_B1 的编号, GPIO0_B2 的编号] grp-\u0026gt;data: [预存的配置值 1, 预存的配置值 2] 第二步：计算内存大小 (算账) # /* * map_num 初始为 1，是为了放 \u0026#34;MUX Map\u0026#34; (复用映射)。 * 加上 grp-\u0026gt;npins，是为了放 \u0026#34;CONFIG Map\u0026#34; (电气配置映射)。 * 每个引脚都需要单独的一个 CONFIG Map。 */ map_num += grp-\u0026gt;npins; /* 申请内存数组 */ new_map = kcalloc(map_num, sizeof(*new_map), GFP_KERNEL); 对应 DTS：我们有两个引脚。所以 map_num = 1 (Mux) + 2 (Configs) = 3。 为什么分开算？ 因为 Linux 规定，“把这一组引脚切到 I2C 模式”是一个动作（MUX），而“把 PB1 设为无上拉”、“把 PB2 设为无上拉”是针对具体引脚的独立动作（CONFIG）。 第三步：构建 MUX Map (填第一张表：复用) # 这是最关键的一步，决定了引脚的功能。\n/* 获取父节点，也就是 DTS 里的 \u0026#34;i2c0\u0026#34; 节点 */ parent = of_get_parent(np); // ... /* 设置类型为 MUX_GROUP (复用组) */ new_map[0].type = PIN_MAP_TYPE_MUX_GROUP; /* 重点！Function 的名字来源于父节点的名字 */ new_map[0].data.mux.function = parent-\u0026gt;name; // \u0026#34;i2c0\u0026#34; /* Group 的名字来源于当前节点的名字 */ new_map[0].data.mux.group = np-\u0026gt;name; // \u0026#34;i2c0-xfer\u0026#34; of_node_put(parent); 逻辑揭秘：这里解释了为什么 Rockchip 的 pinctrl DTS 结构必须是两层！ 父节点名（i2c0）自动变成了 Linux Pinctrl 里的 Function Name。 子节点名（i2c0-xfer）自动变成了 Linux Pinctrl 里的 Group Name。 结果：new_map[0] 告诉核心层：“请把 i2c0-xfer 这一组引脚，切到 i2c0 这个功能上去。” 第四步：构建 CONFIG Map (填剩下的表：电气配置) # /* 指针后移，跳过刚才填好的第0个 map，开始填第1, 2...个 */ new_map++; /* 遍历每一个引脚 (PB1, PB2) */ for (i = 0; i \u0026lt; grp-\u0026gt;npins; i++) { /* 类型是针对单个引脚的配置 */ new_map[i].type = PIN_MAP_TYPE_CONFIGS_PIN; /* 1. 获取这个引脚的名字 (如 \u0026#34;GPIO0_B1\u0026#34;) */ new_map[i].data.configs.group_or_pin = pin_get_name(pctldev, grp-\u0026gt;pins[i]); /* 2. 把之前预解析好的配置值 (\u0026amp;pcfg_pull_none) 塞进去 */ new_map[i].data.configs.configs = grp-\u0026gt;data[i].configs; new_map[i].data.configs.num_configs = grp-\u0026gt;data[i].nconfigs; } 操作：它从 grp 结构体里把之前从 rockchip,pins 解析出来的配置值（比如上拉、驱动能力）直接复制到了 map 里。 结果： new_map[1] 告诉核心层：“把 GPIO0_B1 这个引脚，配置成 pcfg_pull_none。” new_map[2] 告诉核心层：“把 GPIO0_B2 这个引脚，配置成 pcfg_pull_none。” 2. 总结：数据流向图 # 为了让你看透彻，我们画个数据流向：\nDTS 源文件:\ni2c0 { \u0026lt;-- 父节点名 i2c0_xfer { \u0026lt;-- 子节点名 rockchip,pins = \u0026lt;...配置数据...\u0026gt;; } } Rockchip 驱动预处理 (rockchip_pinctrl_parse_groups):\n生成 struct rockchip_pin_group grp: name = \u0026ldquo;i2c0-xfer\u0026rdquo; pins = [PB1, PB2] configs = [NoPull, NoPull] 本函数 (rockchip_dt_node_to_map) 的转换:\n读取 grp 和 父节点名。 生成 Map 数组: Map[0] (MUX): Function: \u0026ldquo;i2c0\u0026rdquo; (来自父节点名) Group: \u0026ldquo;i2c0-xfer\u0026rdquo; (来自子节点名) Map[1] (CONFIG): Pin: \u0026ldquo;GPIO0_B1\u0026rdquo; Config: NoPull Map[2] (CONFIG): Pin: \u0026ldquo;GPIO0_B2\u0026rdquo; Config: NoPull 3. 分析建议 # 下次如果你想自己分析这种函数，抓住这两个重点：\n输入输出是什么？ 这里输入是 device_node (DTS 节点)，输出是 pinctrl_map (Linux 标准结构)。所以这肯定是一个转换函数。 DTS 的层级结构对应代码的哪个变量？ 看到 parent = of_get_parent(np) 和 parent-\u0026gt;name 赋值给 function，你就应该恍然大悟：“原来 Rockchip 强制要求写两层节点，是因为它把父节点名字当成了功能名！” 💻 第四部分：实战 —— 怎么用？（Consumer 角度） # 作为一个驱动工程师，我们通常是 Consumer（消费者）。\n场景 1：最常见的“自动生效” # 你可能会问：“我写 Platform 驱动时，没调用任何 pinctrl 函数，为什么引脚就自动配好了？”\n秘密在于：Linux 的驱动核心模型（Driver Core）在调用你的 probe 函数之前，会自动处理 Pinctrl。\nDTS 写法：\n/* 在你的设备节点里 */ my_device { compatible = \u0026#34;my,device\u0026#34;; /* 核心魔法 */ pinctrl-names = \u0026#34;default\u0026#34;; /* 状态名字叫 default */ pinctrl-0 = \u0026lt;\u0026amp;my_pin_config\u0026gt;; /* 对应具体的引脚配置节点 */ }; /* 在 pinctrl 节点里 (通常在 rk3568-pinctrl.dtsi 或你的 dts 底部) */ \u0026amp;pinctrl { my_pins { my_pin_config: my-pin-config { /* * 格式：\u0026lt;控制器号 引脚号 复用功能 配置\u0026gt; * 0: GPIO0 * 23: 索引号 (对应 PB7) * RK_FUNC_GPIO: 复用为GPIO * \u0026amp;pcfg_pull_up: 启用内部上拉 */ rockchip,pins = \u0026lt;0 RK_PB7 RK_FUNC_GPIO \u0026amp;pcfg_pull_up\u0026gt;; }; }; }; 原理：\n内核加载你的驱动。 在执行 probe 之前，内核核心层调用 pinctrl_bind_pins。 它发现 DTS 里有 pinctrl-names = \u0026quot;default\u0026quot;。 自动把引脚切换到 pinctrl-0 定义的状态。 进入你的 probe 函数时，引脚已经是你想要的状态了！ 场景 2：手动切换状态 # 如果你想在驱动运行过程中，把一个引脚从 GPIO 模式切成 PWM 模式（比如为了省电或分时复用）。或者：控制一个引脚让它在两种状态之间动态切换（以此为例）\n状态 A (Default)：配置为 GPIO 模式，且 上拉 (Pull Up)。 状态 B (Sleep)：配置为 GPIO 模式，但 下拉 (Pull Down)。 C 代码实战\n在 \u0026amp;pinctrl 节点下定义两种“施工方案” \u0026amp;pinctrl { /* 自定义一个子节点 */ my_pinctrl_test { /* 方案 1: 上拉 */ my_pin_active: my-pin-active { /* \u0026lt;控制器号 引脚号 复用功能 配置phandle\u0026gt; */ /* 1 = RK_FUNC_GPIO, \u0026amp;pcfg_pull_up 是内核预定义的节点 */ rockchip,pins = \u0026lt;0 RK_PB7 1 \u0026amp;pcfg_pull_up\u0026gt;; }; /* 方案 2: 下拉 */ my_pin_sleep: my-pin-sleep { /* \u0026amp;pcfg_pull_down 是内核预定义的节点 */ rockchip,pins = \u0026lt;0 RK_PB7 1 \u0026amp;pcfg_pull_down\u0026gt;; }; }; }; 在你的设备节点里“引用”这些方案 my_pinctrl_drv { compatible = \u0026#34;my,pinctrl_test\u0026#34;; /* * 关键！这里定义了两个状态的名字。 * 这里的名字对应代码里 pinctrl_lookup_state 的参数。 */ pinctrl-names = \u0026#34;default\u0026#34;, \u0026#34;my_sleep\u0026#34;; /* 对应上面的方案 */ pinctrl-0 = \u0026lt;\u0026amp;my_pin_active\u0026gt;; /* 对应 default */ pinctrl-1 = \u0026lt;\u0026amp;my_pin_sleep\u0026gt;; /* 对应 my_sleep */ status = \u0026#34;okay\u0026#34;; }; 编写驱动代码 #include \u0026lt;linux/module.h\u0026gt; #include \u0026lt;linux/platform_device.h\u0026gt; #include \u0026lt;linux/pinctrl/consumer.h\u0026gt; /* 必须包含：Pinctrl 消费者头文件 */ #include \u0026lt;linux/delay.h\u0026gt; struct pinctrl *my_pinctrl; struct pinctrl_state *state_default; struct pinctrl_state *state_sleep; static int my_probe(struct platform_device *pdev) { int ret; printk(\u0026#34;========== Pinctrl Test Probe ==========\\n\u0026#34;); /* 1. 获取 Pinctrl 句柄 */ /* 这步会把该设备的所有 Pinctrl 信息读进来 */ my_pinctrl = devm_pinctrl_get(\u0026amp;pdev-\u0026gt;dev); if (IS_ERR(my_pinctrl)) { dev_err(\u0026amp;pdev-\u0026gt;dev, \u0026#34;Failed to get pinctrl\\n\u0026#34;); return PTR_ERR(my_pinctrl); } /* 2. 查找我们在 DTS 里定义的状态 */ /* \u0026#34;default\u0026#34; 对应 pinctrl-0 */ state_default = pinctrl_lookup_state(my_pinctrl, \u0026#34;default\u0026#34;); if (IS_ERR(state_default)) { dev_err(\u0026amp;pdev-\u0026gt;dev, \u0026#34;Could not find default state\\n\u0026#34;); return PTR_ERR(state_default); } /* \u0026#34;my_sleep\u0026#34; 对应 pinctrl-1 */ state_sleep = pinctrl_lookup_state(my_pinctrl, \u0026#34;my_sleep\u0026#34;); if (IS_ERR(state_sleep)) { dev_err(\u0026amp;pdev-\u0026gt;dev, \u0026#34;Could not find sleep state\\n\u0026#34;); return PTR_ERR(state_sleep); } /* 3. 开始表演：切换状态 */ /* 刚进来时，内核应该已经自动帮我们设为 default (上拉) 了 */ printk(\u0026#34;Current State: DEFAULT (Pull-Up)\\n\u0026#34;); /* 你可以在这里测量电压，或者看 debugfs */ msleep(5000); /* 延时5秒，让你有时间反应 */ /* 切换到 Sleep (下拉) */ printk(\u0026#34;Switching to: SLEEP (Pull-Down)...\\n\u0026#34;); ret = pinctrl_select_state(my_pinctrl, state_sleep); if (ret \u0026lt; 0) { dev_err(\u0026amp;pdev-\u0026gt;dev, \u0026#34;Failed to select sleep state\\n\u0026#34;); return ret; } printk(\u0026#34;Switch Success! Check your pin now.\\n\u0026#34;); return 0; } static int my_remove(struct platform_device *pdev) { printk(\u0026#34;Driver Removed\\n\u0026#34;); return 0; } static const struct of_device_id my_match[] = { { .compatible = \u0026#34;my,pinctrl_test\u0026#34; }, { }, }; MODULE_DEVICE_TABLE(of, my_match); static struct platform_driver my_driver = { .probe = my_probe, .remove = my_remove, .driver = { .name = \u0026#34;my_pinctrl_test\u0026#34;, .of_match_table = my_match, }, }; module_platform_driver(my_driver); MODULE_LICENSE(\u0026#34;GPL\u0026#34;); 验证：\n编译并加载： insmod pinctrl_test_drv.ko 观察串口打印，你会看到它先是 Default，5 秒后变成 Sleep。 2. 验证方法一：使用万用表 如果引脚悬空，Pull-Up 时应该是高电平（3.3V）。Pull-Down 时应该是低电平（0V）。 现象：加载驱动 5 秒后，电压跳变。\n验证方法二：使用 Debugfs 在切换发生前（或注释掉切换代码），执行： cat /sys/kernel/debug/pinctrl/pinctrl-rockchip-pinctrl/pinconf-pins | grep 23 (假设 GPIO0_B7 的全局 ID 是 23，具体ID你要自己算一下或者搜一下) 你应该能看到类似 pull up 的字样。在切换发生后，再次执行上面的命令： 你应该能看到它变成了 pull down。\n🕵️‍♂️ 第五部分：调试方法 # 如果引脚没反应，或者电压不对，不要瞎猜，用 Debugfs 查看内核的真实情况。\n1. 查看所有引脚的当前状态\ncat /sys/kernel/debug/pinctrl/pinctrl-rockchip-pinctrl/pins 分析方法：搜索你的引脚号（如 GPIO0_B7 对应的编号）。看它的 owner 是谁？如果是 (null) 说明没申请成功；如果是 my_device 说明被你的驱动占用了。 2. 查看引脚的复用功能 (Mux)\ncat /sys/kernel/debug/pinctrl/pinctrl-rockchip-pinctrl/pinmux-pins 分析方法：看右边的功能。是 gpio 还是 pwm？ 3. 查看引脚的电气配置 (Conf)\ncat /sys/kernel/debug/pinctrl/pinctrl-rockchip-pinctrl/pinconf-pins 分析方法：这能看到更底层的寄存器配置，比如 pull up/down 是否生效。 4. 查看 Maps (设备树解析结果)\ncat /sys/kernel/debug/pinctrl/pinctrl-rockchip-pinctrl/pinmux-maps 分析方法：如果你在 DTS 里写了但没生效，查查这里有没有生成对应的 map。如果没有，说明 DTS 语法或节点位置写错了。 🚀 总结与练习建议 # Pinctrl 的核心流程： DTS (编写配置) -\u0026gt; pinctrl-rockchip.c (解析并注册) -\u0026gt; Driver Core (在 Probe 前自动应用) -\u0026gt; 硬件生效。\n建议的练习步骤：\n只改 DTS：找一个没用的引脚，在设备树里配置它为 GPIO 模式，加一个上拉（pull-up）。 验证：启动板子，不写驱动，直接用万用表量那个脚。如果是高电平（3.3V），说明 Pinctrl 生效了（因为默认可能是悬空或下拉）。 写驱动：按照“场景 2”的代码，写一个简单的驱动，每隔 5 秒切换一次状态（比如改变驱动能力 strength，或者在 GPIO 和特殊功能间切换），用示波器或万用表观察变化。 掌握了 pinctrl-names、pinctrl-0 和 /sys/kernel/debug/pinctrl，你就掌握了 Pinctrl 的精髓！\n","date":"5 December 2025","externalUrl":null,"permalink":"/notes/linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91_pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F/","section":"Notes","summary":"","title":"Linux驱动开发 Pinctrl子系统","type":"notes"},{"content":"","date":"5 December 2025","externalUrl":null,"permalink":"/notes/","section":"Notes","summary":"","title":"Notes","type":"notes"},{"content":"","date":"5 December 2025","externalUrl":null,"permalink":"/","section":"Welcome to My Blog","summary":"","title":"Welcome to My Blog","type":"page"},{"content":"","date":"25 November 2025","externalUrl":null,"permalink":"/tags/linux/","section":"Tags","summary":"","title":"Linux","type":"tags"},{"content":"本篇融合了**【北京迅为】itop-3568 开发板驱动开发指南（重制版）1.8.pdf** 官方文档中平台总线和设备树两章内容，并且带有完整且详尽实例分析，可以先看说明部分理清文章主要所讲内容与侧重点\n关于平台总线 # 一、 为什么需要“平台总线”？ # 1. 没有平台总线时的痛苦 # 假设你写了一个 LED 驱动。\n代码里写死：寄存器地址 = 0xFE001000。 问题： RK3568 的地址是这个，换成 RK3588 地址变了，你得改 C 代码重新编译。 板子上接在 GPIO1，换到 GPIO2，你得改 C 代码重新编译。 结论：驱动代码和硬件参数（地址、中断号）强耦合。移植性极差。 2. 平台总线的思想 # Linux 引入了 “总线 - 设备 - 驱动” 模型。\n驱动（Driver）：只负责逻辑（怎么亮、怎么灭），不包含具体的硬件地址。 设备（Device）：只包含硬件资源（地址是 0xFE\u0026hellip;，中断是 5 号），不包含控制逻辑。 总线（Bus）：红娘。负责把“驱动”和“设备”撮合在一起。 理解 # 想象一下，现在你有 5 款不同的板子，用的都是同一个 LED 驱动逻辑，但 LED 接的引脚不同。\n以前：你需要写 5 个 .c 文件，每个文件里引脚宏定义不同。 现在（平台总线）： 你只需要写 1 个 通用的 .c 驱动文件（不包含任何具体地址）。 你需要写 5 个 不同的 .dts 文件（只包含地址和引脚信息）。 结果：驱动代码实现了“一次编写，到处运行”。这就是 Linux 所谓“机制与策略分离”的体现。 总结 # 没有平台总线概念的时候，驱动和硬件紧密连接，一个硬件参数变了的话，就得改 C 代码重新编译，麻烦； 平台总线：设立了驱动和设备两套代码，驱动负责逻辑（一般般不改变），设备负责硬件参数。以后硬件资源变换了之后，就只需要修改设备代码（简单），不需要改动驱动。平台总线就是把两个东西联合起来。\n二、 平台总线的“铁三角” # 以上所说的驱动，设备，平台总线，对应下面三个结构体。要理解平台总线，必须看懂这三个结构体：\n1. 平台设备 (struct platform_device) —— “我是谁，我在哪” # 代表：硬件设备。 来源：通常不需要手写 C 代码定义它，而是由 设备树 (Device Tree) 解析后自动生成的，就是由写的 dts 自动生成platform_device 。 核心内容： name: 设备名字。 resource: 资源（寄存器物理地址、中断号）。 2. 平台驱动 (struct platform_driver) —— “我会干什么” # 代表：软件驱动程序。 来源：这是你需要手写的 C 代码。 核心内容： probe(): 探测函数。当匹配成功时执行（相当于驱动的入口）。 remove(): 移除函数。 driver.of_match_table: 匹配表（用来和设备树里的 compatible 对暗号）。 3. 平台总线 (platform_bus_type) —— “金牌中介” # 代表：内核里的匹配机制（已经写好了，不用你写）。 工作机制： 每当有一个新驱动注册，总线就会遍历所有设备，问：“你俩匹配吗？” 每当有一个新设备注册，总线就会遍历所有驱动，问：“你俩匹配吗？” 三、 它是怎么“自动匹配”的？ # 系统里有了 platform_device。你加载了 platform_driver。内核发现两者的 .compatible 名字一样（比如都叫 \u0026ldquo;rk3568,led\u0026rdquo;）。 “相亲成功” -\u0026gt; 调用 probe()。\n匹配凭证：主要看 compatible 属性（兼容性字符串）。\n流程讲解 # 左边（设备树/设备）： 你在 DTS 里写了一个节点：\nmy_led { compatible = \u0026#34;rk3568,my-led\u0026#34;; // \u0026lt;--- 暗号 reg = \u0026lt;0xFE001000 0x4\u0026gt;; }; 内核启动时，自动转换成了一个 platform_device，挂在总线左边的链表上。\n右边（驱动代码）： 你写了一个 platform_driver，注册到内核：\nstatic const struct of_device_id my_ids[] = { { .compatible = \u0026#34;rk3568,my-led\u0026#34; }, // \u0026lt;--- 暗号 { } }; /* ... 注册驱动 ... */ 中间（总线匹配）：\n平台总线发现新驱动来了，立刻启动 platform_match 函数。 它拿着驱动里的 \u0026quot;rk3568,my-led\u0026quot; 去跟设备链表里的每一个设备比对。 比对成功！ 触发 Probe：\n总线会自动调用你驱动里的 probe(struct platform_device *pdev) 函数。 并将那个匹配上的设备结构体指针 pdev 传给你。 你在 probe 里，从 pdev 里取出资源（0xFE001000），申请 GPIO，点亮 LED。 五、 代码模板 # 这是你接下来写所有驱动的基础骨架，请务必熟悉：\n#include \u0026lt;linux/module.h\u0026gt; #include \u0026lt;linux/platform_device.h\u0026gt; #include \u0026lt;linux/of.h\u0026gt; // 3. 真正的初始化逻辑在这里（当且仅当匹配成功时执行） static int my_probe(struct platform_device *pdev) { printk(\u0026#34;【平台总线】匹配成功！设备树节点是: %pOF\\n\u0026#34;, pdev-\u0026gt;dev.of_node); // 在这里获取资源、注册字符设备、生成类和节点... // 之前学的 register_chrdev 写在这里面 return 0; } // 4. 清理逻辑 static int my_remove(struct platform_device *pdev) { printk(\u0026#34;【平台总线】驱动移除\\n\u0026#34;); // 注销字符设备... return 0; } // 2. 匹配表（身份证验证） static const struct of_device_id my_match_table[] = { {.compatible = \u0026#34;my_rk3568\u0026#34;}, {} }; MODULE_DEVICE_TABLE(of, my_match_table); // 1. 定义驱动结构体 static struct platform_driver my_driver = { .probe = my_probe, .remove = my_remove, .driver = { .name = \u0026#34;my_driver_v1\u0026#34;, // 在 /sys/bus/platform/drivers/ 下的名字 .of_match_table = my_match_table, // 挂载匹配表 }, }; // 0. 向内核注册这个平台驱动 module_platform_driver(my_driver); MODULE_LICENSE(\u0026#34;GPL\u0026#34;); 总结 # 平台总线是 Linux 用来管理 SoC 内部外设的虚拟总线。 它的核心目的是把“驱动代码”和“硬件地址”拆开。 设备树（DTS） 负责生成 platform_device（提供硬件信息）。 你写的 C 代码 负责注册 platform_driver（提供软件逻辑）。 Probe 函数 是它们“相亲成功”后的约会地点，所有的初始化代码都要从 module_init 搬到 probe 里来。 设备树细节 # 第一阶段：什么是设备树？怎么写它？ # 1. 通俗理解 # 在没有设备树之前，驱动代码里到处都是硬件信息，比如 Base Address = 0xFE001000, IRQ = 5。如果板子改了个电阻，引脚变了，你就得去改 C 代码，重新编译内核。\n设备树（DTS） 就像是一个**“硬件菜单”或“配置文件”**。\nDTS 文件（.dts）：给程序员看的文本文件，描述板子上有哪些硬件（CPU、内存、LED、I2C 控制器）。 DTB 文件（.dtb）：给内核看的二进制文件。DTS 编译后生成 DTB。 驱动代码（.c）：厨师。厨师不记菜单，而是读菜单做菜。 核心思想：把硬件信息（DTS）和驱动逻辑（C 代码）彻底分开。\n2. 基本语法（代码实战） # 设备树是树状结构，只有一个根节点 /。\n代码任务： 我们需要在 RK3568 的设备树文件中，添加一个我们自己的虚拟节点。打开 RK3568 的设备树文件（在内核源码 /Linux/linux_sdk/kernel/arch/arm64/boot/dts/rockchip/rk3568-evb1-ddr4-v10-linux.dts ）在根节点 / { ... }; 内部，添加以下内容：\nrk3568-evb1-ddr4-v10-linux.dts /{ my_test{ #address-cells = \u0026lt;1\u0026gt;; #size-cells = \u0026lt;1\u0026gt;; compatible = \u0026#34;simple-bus\u0026#34;; myLed{ compatible = \u0026#34;my_rk3568\u0026#34;; reg = \u0026lt;0xFDD60000 0x00000004\u0026gt;; }; }; }; compatible：这是最重要的属性！它是驱动程序和设备树节点“相亲”的凭证。驱动代码里也会写一个一模一样的字符串，匹配上了，驱动的 probe 函数才会执行。 设备树展开流程 # dts -\u0026gt; dtb -\u0026gt; device_node -\u0026gt; platform_device (device_node 扁平化结构有点像链表) dts-\u0026gt;dtb 的命令：\n/home/topeet/Linux/linux_sdk/kernel/scripts/dtc/dtc -I dts -O dtb -o test.dtb test.dts 反编译 dtb -\u0026gt; dts\n/home/topeet/Linux/linux_sdk/kernel/scripts/dtc/dtc -I dtb -O dts -o 1.dts test.dtb (DTC 源代码和相关工具放在：/home/topeet/Linux/linux_sdk/kernel/scripts/dtc/dtc)\n在内核启动时会执行 of_platform_default_populate_init()函数，该函数就是将设备树节点（device_node）转换成平台设备（platform_device）的入口函数。 该函数会遍历设备树中的设备节点，并为每个符合条件的设备节点创建一个对应的 platform_device 结构，然后将其注册到内核中，使得设备驱动程序能够识别和操作这些设备。 platform_device 的节点可以在**/sys/bus/platform/devices** 下查看\ndevice_node 转换为 platform_device 的条件/规则 # 规则 1：根节点下有 compatible 属性的子节点。 规则 2：节点中 compatible 属性值是 simple-bus、simple-mfd 和 isa 其中之一，并且该节点下的子节点有 compatible 属性。该节点下的子节点会被转换成 platform_device。 规则 3：节点中compatible属性有arm或 primecell，则对应的节点不会被转换成 platform_device。\n第二阶段：驱动如何“自动”加载？（设备树下 platform_device 和 platform_driver 匹配） # 上面两节，书写了.dts 文件和 driver 驱动，接下来进行实操\n在目录/Linux/linux_sdk下编译内核（./build.sh kernel）并烧写带 my_test 的内核（生成的boot.img在目录/home/topeet/Linux/linux_sdk/kernel/boot.img,烧写时记得接 usb 线）。 编译加载(insmod)这个 .ko 模块。 使用 dmesg 查看，如果你看到“匹配成功！发现设备树节点！”，说明你已经打通了设备树到驱动的任督二脉！ 在驱动里读取设备树数据（OF 操作函数） # 1. 理论讲解 # 目标：在驱动里读取 DTS 里写的参数。如果不掌握这些函数，你的驱动虽然能匹配上（进入 probe），但就像**“进了餐厅却看不懂菜单”**，不知道具体的配置参数（比如阈值是多少、ID 是多少、名字叫什么）。这些以 of_ 开头的函数（Open Firmware），就是用来翻译菜单的工具。 原理：设备树节点中可以包含属性（如 reg, my-value）。驱动匹配成功后，内核会将节点信息保存在 pdev-\u0026gt;dev.of_node 中。我们需要使用 of_property_read_u32 等函数提取这些数据。\n2. 核心概念：节点指针 (device_node) # 在 probe 函数里，你的第一步永远是先拿到“菜单”。这个“菜单”就是 struct device_node 指针。\nstatic int my_probe(struct platform_device *pdev) { // 1. 获取当前设备对应的设备树节点指针 struct device_node *np = pdev-\u0026gt;dev.of_node; if (!np) { printk(\u0026#34;没有设备树节点！\\n\u0026#34;); return -1; } // ... 后面所有的 of_ 函数都要用到这个 np } 3. 最常用的 3 招（覆盖 90% 场景） # 假设我们在设备树里写了这样一个节点：\n/* DTS 文件 */ my_sensor { compatible = \u0026#34;rk3568,sensor\u0026#34;; /* 1. 整数属性 */ sensor-id = \u0026lt;0xA5\u0026gt;; max-speed = \u0026lt;1000\u0026gt;; /* 2. 字符串属性 */ chip-name = \u0026#34;ICm-20608\u0026#34;; /* 3. 数组属性 (很少用，但得知道) */ default-levels = \u0026lt;0 10 20 30\u0026gt;; }; 我们看看如何在驱动代码里把它们读出来。\n1. 读取整数 (of_property_read_u32) # 这是最常用的，用来读 ID、配置参数、波特率等。\n函数原型： int of_property_read_u32(const struct device_node *np, const char *propname, u32 *out_value)\n代码实战：\nu32 id = 0; u32 speed = 0; int ret; /* 读 sensor-id */ ret = of_property_read_u32(np, \u0026#34;sensor-id\u0026#34;, \u0026amp;id); if (ret == 0) { // 成功！注意 DTS 里是 0xA5，读出来就是十进制 165 printk(\u0026#34;读到 ID: %#x\\n\u0026#34;, id); } else { printk(\u0026#34;读取 sensor-id 失败\\n\u0026#34;); } /* 读 max-speed */ of_property_read_u32(np, \u0026#34;max-speed\u0026#34;, \u0026amp;speed); // 简写，假设一定成功 2. 读取字符串 (of_property_read_string) # 用来读取名字、模式配置等。\n函数原型： int of_property_read_string(const struct device_node *np, const char *propname, const char **out_string)\n代码实战：\nconst char *name_str = NULL; // 这是一个指针，指向内核内存 ret = of_property_read_string(np, \u0026#34;chip-name\u0026#34;, \u0026amp;name_str); if (ret == 0) { printk(\u0026#34;芯片名字是: %s\\n\u0026#34;, name_str); } 3. 读取数组 (of_property_read_u32_array) # 用来读取一组数据，比如一些校准参数。\n代码实战：\nu32 levels[4]; // 准备一个数组来接数据 /* 参数：节点，属性名，数组指针，读取数量 */ ret = of_property_read_u32_array(np, \u0026#34;default-levels\u0026#34;, levels, 4); if (ret == 0) { printk(\u0026#34;Level 1: %d\\n\u0026#34;, levels[1]); // 输出 10 } 4. 特殊属性的读取（不要硬用 OF 函数） # 虽然 reg（地址）、interrupts（中断）、gpios（引脚）本质上也是属性，但内核提供了更高级的封装，我们通常不直接用上面的 of_property_read_xxx 来读它们。\n1. 读取 GPIO（关键！） # 不要去读什么 xxx-gpios = \u0026lt;...\u0026gt; 里的数字。 使用 GPIO 子系统接口，内核会自动处理设备树解析。\nDTS: led-gpios = \u0026lt;\u0026amp;gpio0 15 0\u0026gt;;\nCode:\n#include \u0026lt;linux/gpio/consumer.h\u0026gt; struct gpio_desc *my_gpio; /* 内核会自动去DTS找 \u0026#34;led\u0026#34; + \u0026#34;-gpios\u0026#34; 这个属性 */ my_gpio = devm_gpiod_get(\u0026amp;pdev-\u0026gt;dev, \u0026#34;led\u0026#34;, GPIOD_OUT_LOW); 2. 读取资源（reg 和 interrupts） # DTS: reg = \u0026lt;0xFE000000 0x100\u0026gt;;\nCode:\nstruct resource *res; /* IORESOURCE_MEM 表示获取 reg 属性 */ res = platform_get_resource(pdev, IORESOURCE_MEM, 0); // 拿到 resource 后，通常接着用 devm_ioremap_resource 映射内存 DTS: interrupts = \u0026lt;...\u0026gt;;\nCode:\nint irq; irq = platform_get_irq(pdev, 0); // 获取第0个中断号 5. 避坑指南（新手必看） # 返回值检查： 所有 OF 函数，返回 0 表示成功，返回负数（如 -EINVAL）表示失败。不要以为返回 1 是成功！\nu8 / u16 / u32 的区别： 设备树里的数字默认都是 32 位（u32） 的。除非你显式使用了 /bits/ 8 \u0026lt;...\u0026gt; 语法，否则一律用 of_property_read_u32。不要为了省内存用 read_u8，读不出来的。\nconst 指针： of_property_read_string 返回的字符串指针指向的是设备树在内存中的原始数据，是 Read Only 的。千万不要试图去 strcpy 修改它，否则系统会崩。\n6. 总结表 # 你想读什么？ DTS 写法示例 C 代码函数 (推荐) 自定义整数 my-val = \u0026lt;100\u0026gt;; of_property_read_u32 自定义字符串 my-name = \u0026quot;abc\u0026quot;; of_property_read_string GPIO 引脚 xxx-gpios = \u0026lt;...\u0026gt;; devm_gpiod_get (不要直接用 OF) 寄存器地址 reg = \u0026lt;...\u0026gt;; platform_get_resource 中断号 interrupts = \u0026lt;...\u0026gt;; platform_get_irq 掌握了这张表，你在驱动里“读菜单”的能力就完全够用了！\n意义：以后你想修改参数，只需要改 DTS（不用重新编译驱动代码），这就是配置与代码分离。\n控制硬件（GPIO 与 Pinctrl） # 1. 通俗理解 # 这是最复杂的，也是最常用的。\nPinctrl：管脚控制器。RK3568 引脚多，你要在 DTS 里告诉内核：“我要把 GPIO0_A0 这个脚配置成 GPIO 模式，不要用作 PWM”。 GPIO 子系统：配置好模式后，在驱动里控制高低电平。 2. 代码实战（点灯） # Step 1: 修改设备树（DTS） 你需要查看原理图找到 LED 对应的 GPIO 号 GPIO0_B7, 在 DTS 中引用 Pinctrl 配置（迅为的 DTS 通常已经预定义好了 Pinctrl 节点，引用即可）。\n/ { my_led{ compatible = \u0026#34;rk3568,my_led\u0026#34;; status = \u0026#34;okay\u0026#34;; led-gpios = \u0026lt;\u0026amp;gpio0 RK_PB7 GPIO_ACTIVE_HIGH\u0026gt;; }; }; 注意 编写完所有代码之后发现 led 没有反应 排查原因：查看在 dts 中写的 gpio 引脚是否被占用？ cat /sys/kernel/debug/gpio 发现： gpio-15 ( |work ) out hi gpio-15：这就是我们要操作的 GPIO0_B7 (032 + 18 + 7 = 15)。|work：这表示这个引脚当前正在被一个名叫 \u0026ldquo;work\u0026rdquo; 的驱动占用着。out hi：它已经被配置为输出高电平了。也就是说：内核自带的 leds-gpio 驱动（或者类似的系统指示灯驱动）已经根据原厂的设备树，先把这个脚给占用了。 寻找\u0026amp;gpio0 RK_PB7，在：/home/topeet/Linux/linux_sdk/kernel/scripts/dtc/include-prefixes/arm64/rockchip/rk3568-evb.dtsi 中发现 work 驱动\nleds: leds { compatible = \u0026#34;gpio-leds\u0026#34;; work_led: work { status = \u0026#34;disabled\u0026#34;; // ---\u0026gt;添加这一行,使其失效 lable = \u0026#34;user1\u0026#34;; gpios = \u0026lt;\u0026amp;gpio0 RK_PB7 GPIO_ACTIVE_HIGH\u0026gt;; linux,default-trigger = \u0026#34;heartbeat\u0026#34;; default-state = \u0026#34;on\u0026#34;; }; } Step 2: 编写驱动（使用新版 GPIO API）\n#include \u0026lt;linux/module.h\u0026gt; #include \u0026lt;linux/init.h\u0026gt; #include \u0026lt;linux/of.h\u0026gt; #include \u0026lt;linux/platform_device.h\u0026gt; #include \u0026lt;linux/gpio/consumer.h\u0026gt; /* 定义一个指针，指向我们要操作的那个 GPIO */ struct gpio_desc *my_led_gpio; /* * 1. Probe 函数 * 只有当 DTS 的 compatible 和 驱动的 compatible 一样时， * 这个函数才会被内核调用！ */ static int my_prob(struct platform_device *pdev) { printk(KERN_INFO \u0026#34;==========匹配成功！==========\\n\u0026#34;); printk(KERN_INFO \u0026#34;我是驱动，我找到了我的设备！\\n\u0026#34;); if (pdev-\u0026gt;dev.of_node) { printk(KERN_INFO \u0026#34;设备树节点名: %s\\n\u0026#34;, pdev-\u0026gt;dev.of_node-\u0026gt;name); } /* * 【核心步骤：获取 GPIO】 * 参数1: 设备指针 * 参数2: 属性名前缀 \u0026#34;led\u0026#34;。 * 内核会自动在 DTS 里找 \u0026#34;led\u0026#34; + \u0026#34;-gpios\u0026#34; = \u0026#34;led-gpios\u0026#34; 属性。 * 参数3: 初始化标志。GPIOD_OUT_LOW 表示获取后立即设置为输出模式，且输出低电平（灭）。 */ my_led_gpio = devm_gpiod_get(\u0026amp;pdev-\u0026gt;dev, \u0026#34;led\u0026#34;, GPIOD_OUT_LOW); if (IS_ERR(my_led_gpio)) { printk(KERN_ERR \u0026#34;【LED驱动】获取 GPIO 失败！\\n\u0026#34;); return PTR_ERR(my_led_gpio); } /* 点亮 LED！(设置为高电平 1) */ gpiod_set_value(my_led_gpio, 1); printk(KERN_INFO \u0026#34;【LED驱动】灯已点亮！(GPIO0_B7 set High)\\n\u0026#34;); return 0; } static int my_remove(struct platform_device *pdev) { gpiod_set_value(my_led_gpio, 0); /* 注意：使用了 devm_gpiod_get，内核会自动释放 GPIO，不需要手动 free */ printk(KERN_INFO \u0026#34;============= 驱动卸载 ============\\n\u0026#34;); return 0; } /* * 2. 匹配表 * 这是整个匹配过程的核心！ */ static const struct of_device_id my_match_table[] = { {.compatible = \u0026#34;rk3568,my_led\u0026#34;}, {}}; /* 将匹配表注册到模块信息中 */ MODULE_DEVICE_TABLE(of, my_match_table); /* * 3. 驱动结构体 */ static struct platform_driver my_driver = { .probe = my_prob, .remove = my_remove, .driver = { .name = \u0026#34;my_led_driver\u0026#34;, /* 驱动名字，也就是 /sys/bus/platform/drivers/ 下的名字 */ .owner = THIS_MODULE, .of_match_table = my_match_table, /* 关联匹配表 */ }, }; /* 4. 注册平台驱动 */ module_platform_driver(my_driver); MODULE_LICENSE(\u0026#34;GPL\u0026#34;); MODULE_AUTHOR(\u0026#34;Can\u0026#34;); // 作者信息 实操 # 在目录/Linux/linux_sdk下编译内核（./build.sh kernel）并烧写带 my_led 的内核（生成的boot.img在目录/home/topeet/Linux/linux_sdk/kernel/boot.img,烧写时记得接 usb 线）。 编译加载(insmod)这个 .ko 模块。 使用 dmesg 查看，是否与驱动程序中匹配 说明 # 关于官方文档上在平台总线章节里面所说的注册 platform 设备实验，个人认为完全没必要，因为只要会写 dts，完全没必要自己写 platform_device 实验，AI 说：几乎不用 (除非做纯软件实验)。毕竟Linux is a fucking pain in the ass！，笑死\u0026hellip; DTS 的编译原理：不用管 dtc 编译器怎么把文本变成二进制的，会用命令 make dtbs （/home/topeet/Linux/linux_sdk/kernel/scripts/dtc/dtc -I dts -O dtb -o test.dtb test.dts）就行。 DTS 的展开过程：不用管内核启动时怎么把二进制变成结构体的（Unflatten），知道 probe 的时候已经变好了就行。 复杂的总线定义：不用管 CPU 节点、总线控制器节点是怎么写的，那些都是原厂写好的，你只需要在它们下面挂设备。 DTS 语法细节：比如 #address-cells, #size-cells, ranges。这些通常只有在写总线桥接或者内存映射时才用，普通的设备驱动开发几乎不用动。 学习建议与避坑 # 不要死磕 DTS 全部语法：DTS 里有很多复杂的属性（如 ranges, clock-names），初学看不懂很正常。你只需要关注 compatible（匹配用）、reg（地址用）、自定义属性、以及 gpios（引脚用）。 编译是难点：修改 DTS 后，需要重新编译设备树（make dtbs），然后将新的 .img 或 .dtb 烧录到板子上。如果烧录后板子起不来，通常是 DTS 语法写错了。 视频观看顺序： 先看 \u0026ldquo;初识\u0026rdquo; 和 \u0026ldquo;语法\u0026rdquo;。 直接跳到 \u0026ldquo;platform 匹配实验\u0026rdquo;，把驱动框架搭起来。 然后看 \u0026ldquo;of 操作函数\u0026rdquo;，学会读数据。 最后看 \u0026ldquo;GPIO\u0026rdquo; 和 \u0026ldquo;pinctrl\u0026rdquo;，做点灯实验。 至于“设备树展开流程”、“DTB 格式”，那是内核原理，可以等以后有空当故事听，不影响写代码。 按照这个“四步走”路线，每一节都有代码反馈，你会学得很有成就感！加油！\n\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-设备树篇完结\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;\n","date":"25 November 2025","externalUrl":null,"permalink":"/notes/linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91_%E8%AE%BE%E5%A4%87%E6%A0%91/","section":"Notes","summary":"","title":"Linux驱动开发 平台总线\u0026设备树","type":"notes"},{"content":"","date":"25 November 2025","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"25 November 2025","externalUrl":null,"permalink":"/tags/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/","section":"Tags","summary":"","title":"驱动开发","type":"tags"},{"content":"","date":"24 November 2025","externalUrl":null,"permalink":"/tags/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87/","section":"Tags","summary":"","title":"字符设备","type":"tags"},{"content":"虽然现在的 Linux（如 RK3568）通常推荐使用设备树（Device Tree）和 GPIO 子系统（pinctrl/gpiod）来控制 LED，但为了学习字符设备驱动的底层原理，我们需要回归最原始的方法：直接操作寄存器。\n这就好比现在的车都是自动挡（GPIO 子系统），但我们要学开车原理，得先学手动挡（直接操作寄存器）。\n我将以 RK3568 为例，控制的 LED 接在 GPIO0_B7 这个引脚上\n🕵️‍♂️ 前置知识：控制 LED 的三把钥匙 # 要控制一个 LED，我们需要操作三个寄存器（就像三把钥匙）：\n复用寄存器 (IOMUX)：决定这个引脚是干嘛的。引脚可以做串口、PWM，也可以做普通 GPIO。我们要把它设置为 GPIO 模式。 方向寄存器 (DDR - Data Direction Register)：决定数据是进还是出。LED 是发光，所以要设置为 输出 (Output)。 数据寄存器 (DR - Data Register)：决定输出电平的高低。写 1 灯亮，写 0 灯灭（或者反过来）。 📘 第一步：准备手册 # 你需要两份核心文档（RK3568 官方资料）：\nRK3568 底板原理图：查看引脚 D:\\study file\\01iTOP-RK3568 硬件资料\\02底板资料\\01原理图\\02底板原理图\\iTOP_RK3568_C_MAIN_V191.pdf RK3568 TRM (Technical Reference Manual)（技术参考手册）：这是重点，用来查寄存器地址。一定要 Part1 和 Part2 都备好。 D:\\study file\\01iTOP-RK3568 硬件资料\\01核心板资料\\07_RK3568 技术参考手册\\Rockchip RK3568 TRM Part1 V1.1-20210301.pdf 🔍 第二步：寻找“复用寄存器” (IOMUX) # 目标：找到 GPIO0_C0 的复用寄存器地址，并设置为 GPIO 模式。\n在 RK3568 中，复用寄存器通常归 GRF (General Register Files) 管理。\n注意：GPIO0 比较特殊，它属于 PMU 电源域，所以它的复用寄存器在 PMU_GRF 里。 其他 GPIO（如 GPIO1, 2, 3\u0026hellip;）通常在 SYS_GRF 里。 1. 查找基地址 (Base Address) # 打开 TRM Part 1，搜索关键字 Memory Map（内存映射表）。在表中寻找 PMU_GRF：\nPMU_GRF Base Address = 0xFDC20000 2. 查找偏移量 (Offset) # 打开 TRM Part 1 的 GRF 章节，搜索 GPIO0B 或 IOMUX。 你会找到一个寄存器叫 PMU_GRF_GPIO0B_IOMUX_H (L 代表低位，控制 B0-B3；H 代表高位，控制 B4-B7)。\nPMU_GRF_GPIO0B_IOMUX_H Offset: `0x000C 3. 计算物理地址 # 复用寄存器地址 = 基地址 + 偏移量 \u0026gt; 0xFDC20000 + 0x000C = 0xFDC2000c\n4. 怎么设置值？ # 往下翻，查看对应的：PMU_GRF_GPIO0B_IOMUX_H Address: Operational Base + offset (0x000C) 查看想要的 GPIO0_B7，控制 LED 灯需要将引脚复用设置为 GPIO0_B7，\nbit[12:14] 控制 GPIO0_B7。手册会写：\n3'h0: GPIO0_C0 (这是我们要的) 3'h1: PWM*M0 \u0026hellip; 所以，我们要把低 4 位设置为 0。\n*(注：Rockchip 寄存器通常有写保护，高 16 位对应写使能，后面代码里会讲)_\n使用io -r -4 0xFDC2000C 命令可以查看此寄存器的默认值,可以看出复用寄存器值为 00000001,此时[14:12]位为 000,此时 GPIO0_B7 引脚默认为 gpio 功能。因此无需在设置引脚复用为 gpio 功能\n🚦 第三步：寻找“方向寄存器” (DDR) # 这两个寄存器属于 GPIO 控制器 内部。\n1. 查找 GPIO0 的基地址（第一章的 Address Mapping） # GPIO0 0xFDD60000 2. 查找 DDR 的偏移量 # Part 1 的 GPIO 章节（第十六章节）\nGPIO_SWPORT_DDR_L 0x0008 GPIO_SWPORT_DDR_H 0x000C GPIOA0GPIOA7, GPIOB0GPIOB7 对应的方向寄存器偏移地址为 GPIO_SWPORT_DDR_L， GPIOC0GPIOC7, GPIOD0GPIOD7 对应的方向寄存器偏移地址为 GPIO_SWPORT_DDR_H。 因此 GPIO0_B7 引脚方向寄存器的偏移地址为 GPIO_SWPORT_DDR_L，即 0x0008 3. 计算物理地址 # 找到具体的 GPIO_SWPORT_DDR_L 描述：\n31:16 （高16位使能低16位,对应 GPIOA0~GPIOA7、GPIOB0~GPIOB7 引脚方向控制位的写使能） Write enable for lower 16 bits, each bit is individual. 1\u0026#39;b0: Write access disable 1\u0026#39;b1: Write access enable 15:0 （低 16 位控制方向,对应 GPIOA0~GPIOA7, GPIOB0~GPIOB7 方向控制位） Data direction for the lower 16 bits of I/O Port, each bit is individual. 1\u0026#39;b0: Input 1\u0026#39;b1: Output GPIO0_A0 ~ A7 (0-7) GPIO0_B0 ~ B7 (8-15) -\u0026gt; 第 16 个引脚 B7 对应 bit15 GPIO0_C0 ~ C7 (16-23) 使能 bit15：对应 bit31 写 1 控制方向：bit15 写 1 对应输出，0 对应输入 方向寄存器的地址（DDR） = 基地址+偏移地址=0xFDD60000 + 0x0008 = 0xFDD60008 使用 io -r -4 0xfdd60008 命令查看方向寄存器的默认值，方向寄存器第 15 位默认为 1，因此 GPIO0_B7 默认输出。所以无需在设置 GPIO0_B7 方向 第四步：寻找“数据寄存器” (DR) # GPIO_SWPORT_DR_L 0x0000 GPIO_SWPORT_DR_H 0x0004 同上方向寄存器，我们要找的是 低位寄存器 (High)：\n数据寄存器 (DR): GPIO_SWPORT_DR_L，偏移量是 0x0000 数据寄存器的地址（DR）：基地址+偏移地址=0xFDD60000 + 0x0000 = 0xFDD60000 使用io -r -4 0xfdd60000命令查看该寄存器的默认值,该寄存器默认值为 0x0000c040，接下来控制 GPIO0_B7 高低电平需要在此寄存器默认值的基础上进行控制。 找到具体的 数据寄存器（GPIO_SWPORT_DR_L）的描述\nbit16-bit31 对应 GPIOA0GPIOA7、GPIOB0GPIOB7 引脚数据位的写使能。 bit0-bit15 对应 GPIOA0GPIOA7, GPIOB0GPIOB7 数据位 如果要设置 GPIO0_B7 输出电平，需要先将 GPIO0_B7 引脚对应的写使能为 bit31 写 1 使能，然后对 bit15 写入 0 即将 GPIO0_B7 引脚输出低电平，写入 1 则输出高电平。 如果让 GPIO0_B7 输出高电平则需要向数据寄存器写入 0x8000c040 如果输出低电平，需要设置第 15 位为 0 ，第 31 位为 1，那么向数据寄存器中写入**0x80004040**\n📝 总结：我们找到的藏宝图 # 针对 RK3568 GPIO0_B7：\n寄存器名称 物理地址 (Physical Address) 作用 PMU_GRF 0xFDC20000 复用寄存器基地址 PMU_GRF_GPIO0B_IOMUX_H 0x000C 复用寄存器的偏移量，B0-B3 是低位，B4-B7 是高位 PMU_GRF_GPIO0C_IOMUX_H 0xFDC2000c 设为 GPIO 模式 GPIO0 0xFDD60000 基于此设置 DR 和 DDR 寄存器，只需要加上偏移量即可 GPIO_SWPORT_DDR_L 0x0008 方向寄存器的偏移地址 GPIO_SWPORT_DDR_L 0xFDD60008 设为输出模式 GPIO_SWPORT_DR_L 0x0000 数据寄存器的偏移地址 GPIO0_SWPORT_DR_L 0xFDD60000 写 1 亮，写 0 灭 除了这些，还有一些规则，具体在代码里面体现，主要是使用writel函数，在计算完方向/数据寄存器地址之后控制方向与数据\n💻 代码实战：如何在驱动里用这些地址？ # 在 Linux 驱动中，我们不能直接操作物理地址（那是会报错的）。我们必须使用 ioremap 把物理地址映射成虚拟地址。 主要设计函数 ioremap 、writel、 iounmap。 在 init 函数中主要进行\n映射地址；\n设置复用寄存器（目的是设置为 GPIO 模式）；\n设置方向寄存器（目的是设置为 Output）；\n初始化状态（关灯）\n而在 write 函数中，主要是通过判断传入的指令（开灯？关灯？），进而对数据寄存器进行不同的操作\n驱动代码片段 (led_drv.c) # #include \u0026lt;linux/init.h\u0026gt; #include \u0026lt;linux/module.h\u0026gt; #include \u0026lt;linux/fs.h\u0026gt; #include \u0026lt;linux/types.h\u0026gt; #include \u0026lt;linux/cdev.h\u0026gt; #include \u0026lt;linux/device.h\u0026gt; #include \u0026lt;linux/uaccess.h\u0026gt; #include \u0026lt;linux/slab.h\u0026gt; #include \u0026lt;linux/io.h\u0026gt; // 定义设备名 #define CLA_NAME \u0026#34;led_class\u0026#34; #define DEV_NAME \u0026#34;led_device\u0026#34; #define DEV_NUM \u0026#34;led_dev\u0026#34; // 基地址 #define RK3568_PMU_GRF_BASE 0xFDC20000 #define RK3568_GPIO0_BASE 0xFDD60000 // 偏移量 // 复用寄存器：PMU_GRF_GPIO0B_IOMUX_H (控制 GPIO0_B0 ~ B7) #define PMU_GRF_GPIO0B_IOMUX_H_OFFSET 0x000C // 数据寄存器：GPIO0_B7 属于低16位 (Bit 15)，所以用 DR_L #define GPIO_SWPORT_DR_L_OFFSET 0x0000 // 方向寄存器：GPIO0_B7 属于低16位 (Bit 15)，所以用 DDR_L #define GPIO_SWPORT_DDR_L_OFFSET 0x0008 // 规则 // 复用寄存器 需要把高16位对应的 bits [30:28] 置 1 来使能写操作 值: (0x7 \u0026lt;\u0026lt; 28) | (0x0 \u0026lt;\u0026lt; 12) = 0x7000 0000 #define PMU_REGULAR 0x70000000 // 方向寄存器 Bit 15 + 16 = Bit 31 是写使能位 值: (1 \u0026lt;\u0026lt; 31) | (1 \u0026lt;\u0026lt; 15) = 0x80008000 #define DDR_REGULAR 0x80008000 // 开灯：Bit 31 置1(使能), Bit 15 置1(高电平) -\u0026gt; 0x8000 8000 #define LED_OPEN_VAL 0x80008000 // 关灯：Bit 31 置1(使能), Bit 15 置0(低电平) -\u0026gt; 0x8000 0000 #define LED_CLOSE_VAL 0x80000000 // LED控制 #define LED_CLOSE 0x80004040 #define LED_OPEN 0x8000c040 struct device_test { /* data */ dev_t dev; // 设备号 int major; int minor; struct cdev my_cdev; //// 结构体和设备号关联起来 struct class *my_class; struct device *my_device; char buff[128]; void __iomem *vir_gpio0; // 映射 GPIO0 基地址 void __iomem *vir_pmu_grf; // 用于复用控制 }; struct device_test dev1; static int myopen(struct inode *inode, struct file *file) { /*在使用时一般将设备结构体指向 file 结构体中 private_data 成员，此时设备结构体就变成了文件私有数据 对 file 结构体中 private_data 成员赋值一般是在文件操作集中的 open() 函数中赋值*/ file-\u0026gt;private_data = \u0026amp;dev1; printk(KERN_INFO \u0026#34;-------------迅为RK3568: 设备被打开了\\n\u0026#34;); return 0; } static ssize_t mywrite(struct file *file, const char __user *buf, size_t size, loff_t *ppos) { /*通 file 结构体可以将私有数据一路从 open()函数带到 read(), write()函数。接着就是可以在 read()、write()函数中使用文件私有数据。*/ struct device_test *test_dev = (struct device_test *)file-\u0026gt;private_data; void __iomem *dr_addr = test_dev-\u0026gt;vir_gpio0 + GPIO_SWPORT_DR_L_OFFSET; int ret = copy_from_user(test_dev-\u0026gt;buff, buf, size); // 应用层将buff传入内核 if (ret != 0) { printk(KERN_ERR \u0026#34;******copy_from_user error!\\n\u0026#34;); return -ret; } // 计算数据寄存器虚拟地址 if (dev1.buff[0] == 0) // 如果传入的是0 则关灯 { writel(LED_CLOSE_VAL, dr_addr); // 对指针 “解引用”，访问指针指向的内存单元（即 GPIO 寄存器本身），可读写其值 printk(\u0026#34;LED Driver: OFF (Write 0x%X)\\n\u0026#34;, LED_CLOSE_VAL); } if (dev1.buff[0] == 1) // 如果传入的是1 则开灯 { writel(LED_OPEN_VAL, dr_addr); printk(\u0026#34;LED Driver: ON (Write 0x%X)\\n\u0026#34;, LED_OPEN_VAL); } printk(\u0026#34;--------------写入数据到私有内存：%s\\n\u0026#34;, test_dev-\u0026gt;buff); return size; } static ssize_t myread(struct file *file, char __user *buf, size_t size, loff_t *ppos) { struct device_test *test_device = file-\u0026gt;private_data; int ret = copy_to_user(buf, test_device-\u0026gt;buff, size); if (ret) { printk(\u0026#34;-----------------read error\\n\u0026#34;); return -ret; } printk(\u0026#34;-------------从私有内存读取数据: %s\\n\u0026#34;, test_device-\u0026gt;buff); return size; } // --- 4. 关闭设备 (退房) --- static int myrealse(struct inode *inode, struct file *file) { printk(KERN_INFO \u0026#34;-------------迅为RK3568: 设备被释放了\\n\u0026#34;); return 0; } static struct file_operations my_ops = { /* 顾客来了能做什么,定义商店的经营方法 */ .owner = THIS_MODULE, .open = myopen, .read = myread, .write = mywrite, .release = myrealse, }; static int __init module_cdev_init(void) // 驱动入口函数 { int ret; // --- 1.申请设备号 （动态申请）--- ret = alloc_chrdev_region(\u0026amp;dev1.dev, 0, 1, DEV_NUM); if (ret \u0026lt; 0) { printk(\u0026#34;-----------------alloc_chrdev_region error\\n\u0026#34;); // 申请设备号失败 return ret; } printk(\u0026#34;--------------alloc_chrdev_region succeed,major %d，minor %d\\n\u0026#34;, MAJOR(dev1.dev), MINOR(dev1.dev)); // 营业执照申请成功！ // --- 2. 注册字符设备 --- cdev_init(\u0026amp;dev1.my_cdev, \u0026amp;my_ops); // 将 cdev 添加到内核 ret = cdev_add(\u0026amp;dev1.my_cdev, dev1.dev, 1); // 为什么是1 if (ret \u0026lt; 0) { printk(\u0026#34;------------------cdev_add error\\n\u0026#34;); // 注册经营范围失败 goto free_dev; } printk(\u0026#34;--------------cdev_add secceed\\n\u0026#34;); // 经营范围已在工商局注册 // --- 3. 创建设备节点 --- // 创建一条“商业街” dev1.my_class = class_create(THIS_MODULE, CLA_NAME); if (IS_ERR(dev1.my_class)) { // 错误处理... printk(KERN_ERR \u0026#34;---------------class_create error\\n \u0026#34;); ret = PTR_ERR(dev1.my_class); // 把指针错误转换成错误码(int) // 这里失败了，要撤销第二关(cdev)和第一关(设备号) goto destroy_cdev; } printk(KERN_INFO \u0026#34;---------------private_class : 店铺已在 /sys/class/ 挂牌营业！\\n \u0026#34;); // 在商业街上创建我们的“店面”，并取名 \u0026#34;mydevice111\u0026#34; // 参数: 类, 父设备(NULL), 设备号, 私有数据(NULL), 设备名 dev1.my_device = device_create(dev1.my_class, NULL, dev1.dev, NULL, DEV_NAME); if (IS_ERR(dev1.my_device)) { // 错误处理... printk(KERN_ERR \u0026#34;---------------device_create error\\n \u0026#34;); ret = PTR_ERR(dev1.my_device); // 这里失败了，要撤销第三关(类)、第二关(cdev)、第一关(设备号) goto destroy_class; } printk(KERN_INFO \u0026#34;---------------MyDevice : 店铺已在 / dev / mydevice111 挂牌营业！\\n \u0026#34;); /*添加*/ // --- 硬件初始化 --- // A. 映射地址 (映射 4KB 足够覆盖寄存器) dev1.vir_gpio0 = ioremap(RK3568_GPIO0_BASE, 4096); dev1.vir_pmu_grf = ioremap(RK3568_PMU_GRF_BASE, 4096); if (!dev1.vir_pmu_grf || !dev1.vir_gpio0) { printk(\u0026#34;ioremap error!\\n\u0026#34;); return -ENOMEM; goto destroy_ioremap; } // B. 设置复用 (IOMUX) -\u0026gt; 设为 GPIO 模式 // 寄存器: PMU_GRF_GPIO0B_IOMUX_H (Offset 0x0C) // GPIO0_B7 对应 bits [14:12]，模式 000 是 GPIO // 写规则: 需要把高16位对应的 bits [30:28] 置 1 来使能写操作 // 值: (0x7 \u0026lt;\u0026lt; 28) | (0x0 \u0026lt;\u0026lt; 12) = 0x7000 0000 writel(PMU_REGULAR, dev1.vir_pmu_grf + PMU_GRF_GPIO0B_IOMUX_H_OFFSET); printk(\u0026#34;LED Driver: IOMUX Set to GPIO\\n\u0026#34;); // C. 设置方向 (DDR) -\u0026gt; 设为 Output // 寄存器: GPIO_SWPORT_DDR_L (Offset 0x08) // GPIO0_B7 对应 Bit 15 // 写规则: Bit 15 + 16 = Bit 31 是写使能位 // 值: (1 \u0026lt;\u0026lt; 31) | (1 \u0026lt;\u0026lt; 15) = 0x80008000 writel(DDR_REGULAR, dev1.vir_gpio0 + GPIO_SWPORT_DDR_L_OFFSET); printk(\u0026#34;LED Driver: Direction Set to Output\\n\u0026#34;); // D：默认关灯 操作数据寄存器 writel(LED_CLOSE_VAL, dev1.vir_gpio0 + GPIO_SWPORT_DR_L_OFFSET); printk(\u0026#34;LED Driver: Init Success!\\n\u0026#34;); return 0; destroy_ioremap: if (dev1.vir_pmu_grf) // 成功的才还 如果dev1.vir_pmu_grf成功，但是vir_gpio0失败，要销毁成功的 iounmap(dev1.vir_pmu_grf); if (dev1.vir_gpio0) iounmap(dev1.vir_gpio0); device_destroy(dev1.my_class, dev1.dev); destroy_class: class_destroy(dev1.my_class); destroy_cdev: cdev_del(\u0026amp;dev1.my_cdev); free_dev: unregister_chrdev_region(dev1.dev, 1); return ret; } // 驱动出口函数 static void __exit module_cdev_exit(void) { // 取消映射 iounmap(dev1.vir_pmu_grf); iounmap(dev1.vir_gpio0); // 3.销毁设备节点 device_destroy(dev1.my_class, dev1.dev); class_destroy(dev1.my_class); // 2.注销字符设备 cdev_del(\u0026amp;dev1.my_cdev); // 1.归还设备号 unregister_chrdev_region(dev1.dev, 1); printk(KERN_INFO \u0026#34;----------------MyDevice: 店铺已摘牌，打烊了！\\n\u0026#34;); // MyDevice: 店铺已摘牌，打烊了！ } module_init(module_cdev_init); // 注册入口函数 module_exit(module_cdev_exit); // 注册出口函数 MODULE_LICENSE(\u0026#34;GPL v2\u0026#34;); // 同意GPL开源协议 MODULE_AUTHOR(\u0026#34;Can\u0026#34;); // 作者信息 // 你的驱动已经可以在加载后自动创建 /dev/mydevice 文件了！ 🔥 重点提示（避坑指南） # 写使能位（Write Mask）：这是 Rockchip 芯片最著名的特点！ 大多数寄存器（尤其是 GRF 和 GPIO），高 16 位是“写保护锁”。\n如果你想修改 bit 0，你必须同时把 bit 16 写为 1。 如果你只写 bit 0 = 1，但 bit 16 = 0，硬件会忽略你的操作。 公式：val = (1 \u0026lt;\u0026lt; (bit + 16)) | (value \u0026lt;\u0026lt; bit); iomap 失败： 如果 ioremap 失败，通常是因为这段地址已经被内核的其他驱动（比如原生的 GPIO 驱动）申请走了。在实验阶段，可以在设备树里把对应的 GPIO 节点 status = \u0026quot;disabled\u0026quot;; 掉，防止冲突。\nH 和 L 的区分： RK3568 一个 GPIO Port 有 32 个引脚（A, B, C, D 各 8 个）。\n_L 寄存器通常管 A 和 B (0-15)。 _H 寄存器通常管 C 和 D (16-31)。 一定要数清楚你的引脚是第几个。 希望这个讲解能帮你顺利找到寄存器，点亮那颗 LED！\n","date":"24 November 2025","externalUrl":null,"permalink":"/notes/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8_led/","section":"Notes","summary":"","title":"字符设备驱动 LED","type":"notes"},{"content":" 🌟 核心概念：什么是字符设备？ # 在 Linux 的世界里，一切皆文件。 字符设备（Character Device）就是像水流一样，按顺序一个字节一个字节传输数据的设备。\n例子：键盘、鼠标、串口、LED 灯、蜂鸣器。 目的：你的驱动程序要把硬件伪装成一个文件（例如 /dev/my_led），让应用程序可以通过 open、read、write 这些标准函数来控制硬件。 🏗️ 第一关：传统功夫 —— 手动打造字符设备驱动 # (知识点：申请设备号、注册 cdev、cdev_add)\n🗣️ 通俗讲解 # 你要在 Linux 内核里开一家“店”（驱动），必须办两件事：\n申请营业执照（设备号）：\n主设备号：代表行业（比如“这是 LED 行业”）。 次设备号：代表具体分店（比如“这是 LED 1 号店，那是 LED 2 号店”）。 静态申请设备号：register_chrdev_region（申请前需要MKDEV(major, minor)传入主次设备号）。 动态申请设备号：alloc_chrdev_region（让内核自动分配一个没被占用的号码，更安全）。 关联具体操作与营业执照：\n拿到执照后，你要告诉工商局(内核)，顾客来了能做什么。比如，可以“开门”(open)，“读取商品信息”(read)，“下单”(write)。这些操作的集合，就是一个 file_operations 结构体。我们需要把这个结构体和设备号关联起来，这个过程叫注册字符设备 (cdev)。 💻 代码实践 # 这是一个最基础的驱动骨架，加载后内核里有了你的位置，但还没有文件节点。\n#include \u0026lt;linux/module.h\u0026gt; #include \u0026lt;linux/init.h\u0026gt; #include \u0026lt;linux/fs.h\u0026gt; #include \u0026lt;linux/cdev.h\u0026gt; // 定义设备名 #define DEV_NAME \u0026#34;test_chrdev\u0026#34; // 全局变量 static dev_t dev_num; // 存放申请到的设备号(主+次) static struct cdev my_cdev; // 字符设备核心结构体 // 1. 定义文件操作集 (店员的工作手册) // 目前什么都不做，只是为了编译通过 static int my_open(struct inode *inode, struct file *file) { printk(\u0026#34;迅为RK3568: 设备被打开了\\n\u0026#34;); return 0; } static struct file_operations my_fops = { /* 顾客来了能做什么,定义商店的经营方法 */ .owner = THIS_MODULE, .open = my_open, }; // 2. 驱动入口 (开业) static int __init my_driver_init(void) { int ret; // A. 动态申请设备号 // 参数: 存放结果的指针, 次设备号起始(0), 申请数量(1), 名字 ret = alloc_chrdev_region(\u0026amp;dev_num, 0, 1, DEV_NAME); if (ret \u0026lt; 0) { printk(\u0026#34;申请设备号失败\\n\u0026#34;); return ret; } printk(\u0026#34;申请成功: 主设备号=%d, 次设备号=%d\\n\u0026#34;, MAJOR(dev_num), MINOR(dev_num)); // B. 初始化cdev (绑定我们要用的操作函数集) cdev_init(\u0026amp;my_cdev, \u0026amp;my_fops); // C. 添加cdev到内核 (正式注册) ret = cdev_add(\u0026amp;my_cdev, dev_num, 1); if (ret \u0026lt; 0) { printk(\u0026#34;注册cdev失败\\n\u0026#34;); unregister_chrdev_region(dev_num, 1); // 失败了记得退还设备号 return ret; } printk(\u0026#34;字符设备注册完成！\\n\u0026#34;); return 0; } // 3. 驱动出口 (关门) static void __exit my_driver_exit(void) { // A. 删除cdev cdev_del(\u0026amp;my_cdev); // B. 归还设备号 unregister_chrdev_region(dev_num, 1); printk(\u0026#34;字符设备已卸载\\n\u0026#34;); } module_init(my_driver_init); module_exit(my_driver_exit); MODULE_LICENSE(\u0026#34;GPL\u0026#34;); 🚪 第二关：自动挂牌 —— 创建设备节点 # (知识点：class_create, device_create)\n🗣️ 通俗讲解 # 在第一关，你的店注册了，但是在街道上（/dev/ 目录）没有门牌，用户找不到你。这个门牌就是 /dev 目录下的一个文件，比如 /dev/mydevice.我们希望加载驱动时，这个文件能自动出现；卸载时，自动消失。\n创建类 (class_create)：在 /sys/class 下建个分类目录。 相当于创建一条商业街 创建设备 (device_create)：在分类下建个设备信息，系统会自动在 /dev 下生成对应的文件。在商业街上创建我们的“店面”，并取名 💻 代码实践 # 在第一关的基础上，增加自动创建节点的代码。\n// ... (保留上面的头文件和变量) #include \u0026lt;linux/device.h\u0026gt; // 新增头文件 static struct class *my_class; // 类 static struct device *my_device; // 设备 static int __init my_driver_init(void) { // ... (alloc_chrdev_region 和 cdev_add 代码同上，省略) ... // 1. 创建类 (会在 /sys/class/ 下生成 my_class_test 目录) // 创建一条“商业街” my_class = class_create(THIS_MODULE, \u0026#34;my_class_test\u0026#34;); if (IS_ERR(my_class)) { return PTR_ERR(my_class); } // 2. 创建设备节点 (会在 /dev/ 下生成 my_device_node 文件) // 在商业街上创建我们的“店面”，并取名 \u0026#34;my_device_node\u0026#34; // 参数: 类, 父设备(NULL), 设备号, 私有数据(NULL), 设备名 my_device = device_create(my_class, NULL, dev_num, NULL, \u0026#34;my_device_node\u0026#34;); if (IS_ERR(my_device)) { class_destroy(my_class); // 失败了要回滚 return PTR_ERR(my_device); } printk(\u0026#34;设备节点 /dev/my_device_node 已自动生成\\n\u0026#34;); return 0; } static void __exit my_driver_exit(void) { // --- 新增步骤 3.销毁设备节点 (注意顺序：先销毁设备，再销毁类) --- device_destroy(my_class, dev_num); class_destroy(my_class); // 2.注销字符设备 cdev_del(\u0026amp;my_cdev); // 1.归还设备号 unregister_chrdev_region(dev, 1); printk(KERN_INFO \u0026#34;----------------MyDevice: 店铺已摘牌，打烊了！\\n\u0026#34;); } 验证：加载驱动后，直接 ls /dev/my_device_node，你会发现文件已经存在了。\n📦 第三关：数据搬运 —— 用户与内核的交互 # (知识点：copy_to_user, copy_from_user)\n🗣️ 通俗讲解 # Linux 为了安全，把内存划分为用户空间（APP）和内核空间（驱动）。它们之间有一堵墙，不能直接互传指针。\nAPP 写数据给驱动 (write)：驱动必须用 copy_from_user 把数据从墙外拉进来。顾客（用户）把东西给仓库（内核） copy_from_user(void *to, const void __user *from, unsigned long n) // to: 给谁？从用户空间拿来数据要给谁？当然是内核空间了。 kbuf(仓库自己的箱子)：目的地。 // from:从哪里来？当然是从用户空间来了。 buf (顾客手里的箱子)：源头。用户空间的数据地址。 // size (数量)：要拿多少个苹果。 驱动发数据给 APP (read)：驱动必须用 copy_to_user 把数据扔到墙外去。仓库（内核）把东西给顾客（用户）。\ncopy_from_user 和 copy_to_user 是对驱动而言；read 和 write 是对用户而言\n💻 代码实践 # 实现一个简单的读写回显功能。\n#include \u0026lt;linux/uaccess.h\u0026gt; // 必须包含这个头文件 static char kbuf[128] = {0}; // 内核里的缓冲区 // 读函数：APP读取时调用 static ssize_t my_read(struct file *file, char __user *buf, size_t size, loff_t *ppos) { // copy_to_user(用户地址, 内核地址, 长度) // 返回值：没拷贝成功的字节数，0表示全成功 int ret = copy_to_user(buf, kbuf, size); if(ret) { return -EFAULT; } printk(\u0026#34;APP读走了数据: %s\\n\u0026#34;, kbuf); return size; } // 写函数：APP写入时调用 static ssize_t my_write(struct file *file, const char __user *buf, size_t size, loff_t *ppos) { // copy_from_user(内核地址, 用户地址, 长度) int ret = copy_from_user(kbuf, buf, size); if(ret) { return -EFAULT; } printk(\u0026#34;APP写入了数据: %s\\n\u0026#34;, kbuf); return size; } // 记得把这两个函数填入 file_operations 结构体 static struct file_operations my_fops = { .owner = THIS_MODULE, .open = my_open, .read = my_read, .write = my_write, }; 🚀 第四关：极简模式 —— 杂项设备驱动 (Misc Device) # (知识点：misc_register)\n🗣️ 通俗讲解 # 如果你觉得上面的 alloc_chrdev -\u0026gt; cdev -\u0026gt; class -\u0026gt; device 这一套流程太繁琐了，Linux 提供了一个懒人包：杂项设备 (Misc Device)。\n它自动固定主设备号为 10。 它自动帮你申请次设备号。 它自动帮你创建 /dev/ 下的节点。 非常适合：简单的字符设备（蜂鸣器、看门狗、ADC 等）。 💻 代码实践 # 你会发现代码量瞬间减少。\n#include \u0026lt;linux/module.h\u0026gt; #include \u0026lt;linux/init.h\u0026gt; #include \u0026lt;linux/miscdevice.h\u0026gt; // 核心头文件 #include \u0026lt;linux/fs.h\u0026gt; // 定义操作函数 static int my_misc_open(struct inode *inode, struct file *file) { printk(\u0026#34;Misc设备被打开\\n\u0026#34;); return 0; } static struct file_operations misc_fops = { .owner = THIS_MODULE, .open = my_misc_open, }; // 定义杂项设备结构体 static struct miscdevice my_misc_dev = { .minor = MISC_DYNAMIC_MINOR, // 自动分配次设备号 .name = \u0026#34;my_misc_test\u0026#34;, // 自动生成 /dev/my_misc_test .fops = \u0026amp;misc_fops, }; static int __init my_misc_init(void) { // 一步注册！ int ret = misc_register(\u0026amp;my_misc_dev); if (ret \u0026lt; 0) { printk(\u0026#34;Misc注册失败\\n\u0026#34;); return ret; } printk(\u0026#34;Misc驱动注册成功\\n\u0026#34;); return 0; } static void __exit my_misc_exit(void) { // 一步卸载 misc_deregister(\u0026amp;my_misc_dev); printk(\u0026#34;Misc驱动卸载\\n\u0026#34;); } module_init(my_misc_init); module_exit(my_misc_exit); MODULE_LICENSE(\u0026#34;GPL\u0026#34;); 🧩 第五关：高手进阶 —— 私有数据与一驱多用 # (知识点：private_data, container_of, 面向对象的思想)\n🗣️ 通俗讲解 # 这是从入门到进阶最关键的一步。 问题：如果 RK3568 板子上有 3 个 LED 灯，难道我要写 3 个驱动（led1_drv, led2_drv\u0026hellip;）吗？ 答案：当然不！我们要写1 个驱动，管理3 个设备。\n怎么做？\n定义一个结构体：把每个 LED 的属性（比如 GPIO 号、名字）包起来。 使用 private_data：当 APP 打开 /dev/led1 时，驱动在 open 函数里识别出是“1 号灯”，然后把 1 号灯的结构体指针存入 file-\u0026gt;private_data 这个“背包”里。 读写时：在 write 函数里，从“背包”里拿出数据，就知道现在操作的是哪个灯，而不会乱套。 没问题！这一关确实是 Linux 驱动开发中从新手到老手的分水岭。如果只用全局变量，那叫“裸机思维”；学会用 private_data，才算真正有了“Linux 驱动思维”。\n我们换一个更直观的场景：住酒店。\n🏨 通俗讲解：全局变量 vs 私有数据 # 假设你开了一家酒店（驱动程序），有一个房间（内存缓冲区）。\n1. 全局变量的做法（错误示范） # 你酒店里只有一个公共储物柜（全局变量 static char kbuf[128]）。\n客人 A（APP 1） 入住，把他的 钱包 放进了柜子。 客人 B（APP 2） 入住，把他的 臭袜子 放进了同一个柜子（覆盖了钱包）。 客人 A 想要取回东西，结果拿出了一双 臭袜子。 后果：客人打起来了，数据乱套了。 2. 私有数据的做法（private_data） # Linux 内核设计了一套机制：\nOpen (办理入住)：当前台（open函数）接到客人时，立马给客人分配一个专属房间（kmalloc 申请一块内存），并把房卡（内存地址）挂在客人的档案（file结构体）上的 private_data 字段里。 Write/Read (回房间办事)：客人要存取东西时，必须出示档案。驱动通过 file-\u0026gt;private_data 拿到房卡，找到只属于这个客人的房间进行操作。 Release (退房)：客人走的时候，驱动回收房卡，并打扫房间（kfree 释放内存）。 结论：不管有多少个客人同时入住，每个人都只在自己的房间里折腾，互不干扰。\n💻 代码实战：多 APP 数据隔离实验 # 这个驱动实现了：APP 1 写入的数据，只有 APP 1 能读到；APP 2 写入的数据，只有 APP 2 能读到。 即使它们打开的是同一个设备文件 /dev/test_private。\n1. 驱动代码 (private_data_drv.c) # #include \u0026lt;linux/init.h\u0026gt; #include \u0026lt;linux/module.h\u0026gt; #include \u0026lt;linux/fs.h\u0026gt; #include \u0026lt;linux/cdev.h\u0026gt; #include \u0026lt;linux/device.h\u0026gt; #include \u0026lt;linux/uaccess.h\u0026gt; #include \u0026lt;linux/slab.h\u0026gt; // 必须包含！为了使用 kmalloc 和 kfree // 定义设备名 #define DEV_NAME \u0026#34;test_private\u0026#34; // 核心：定义一个结构体，代表“一个客人的专属房间” struct session_data { char buffer[128]; // 客人的私有储物柜 }; // 全局变量只用来管“执照”和“门牌”，不管具体数据 static dev_t dev_num; static struct cdev my_cdev; static struct class *my_class; static struct device *my_device; // --- 1. 打开设备 (办理入住) --- static int my_open(struct inode *inode, struct file *file) { // A. 为当前这个“客人”申请一块独立的内存 (开一间新房) // GFP_KERNEL 表示正常的内核内存分配 struct session_data *new_data = kmalloc(sizeof(struct session_data), GFP_KERNEL); if (!new_data) { return -ENOMEM; // 内存不足，入住失败 } // B. 初始化一下内存，清零 memset(new_data, 0, sizeof(struct session_data)); // C. 关键！！把房间钥匙(地址)挂在 file-\u0026gt;private_data 上 // 以后这个 file 指针不管传给 read 还是 write，我们都能找回这块内存 file-\u0026gt;private_data = new_data; printk(\u0026#34;驱动日志: 这里的 open 被调用了，已分配私有内存地址: %p\\n\u0026#34;, new_data); return 0; } // --- 2. 写入数据 (存东西) --- static ssize_t my_write(struct file *file, const char __user *buf, size_t size, loff_t *ppos) { int ret; // A. 关键！！从 private_data 里拿出当事人的专属内存指针 struct session_data *data = (struct session_data *)file-\u0026gt;private_data; // 防止溢出 if (size \u0026gt; 128) size = 128; // B. 把数据写入到“他的”buffer里，而不是全局变量里 ret = copy_from_user(data-\u0026gt;buffer, buf, size); if (ret) return -EFAULT; printk(\u0026#34;驱动日志: 写入数据到私有内存(%p): %s\\n\u0026#34;, data, data-\u0026gt;buffer); return size; } // --- 3. 读取数据 (取东西) --- static ssize_t my_read(struct file *file, char __user *buf, size_t size, loff_t *ppos) { int ret; // A. 关键！！拿出当事人的指针 struct session_data *data = (struct session_data *)file-\u0026gt;private_data; // B. 从“他的”buffer里读数据 ret = copy_to_user(buf, data-\u0026gt;buffer, size); if (ret) return -EFAULT; printk(\u0026#34;驱动日志: 从私有内存(%p)读取数据: %s\\n\u0026#34;, data, data-\u0026gt;buffer); return size; } // --- 4. 关闭设备 (退房) --- static int my_release(struct inode *inode, struct file *file) { // A. 取出指针 struct session_data *data = (struct session_data *)file-\u0026gt;private_data; // B. 释放内存 (一定要做！否则这块内存就丢了，这叫内存泄漏) if (data) { printk(\u0026#34;驱动日志: 释放私有内存地址: %p\\n\u0026#34;, data); kfree(data); } return 0; } // 操作函数集 static struct file_operations my_fops = { .owner = THIS_MODULE, .open = my_open, .read = my_read, .write = my_write, .release = my_release, }; // 驱动入口 static int __init my_init(void) { // 动态申请设备号 alloc_chrdev_region(\u0026amp;dev_num, 0, 1, DEV_NAME); // 初始化cdev cdev_init(\u0026amp;my_cdev, \u0026amp;my_fops); cdev_add(\u0026amp;my_cdev, dev_num, 1); // 自动创建节点 my_class = class_create(THIS_MODULE, \u0026#34;private_class\u0026#34;); my_device = device_create(my_class, NULL, dev_num, NULL, DEV_NAME); printk(\u0026#34;驱动日志: 驱动加载成功，设备节点 /dev/%s\\n\u0026#34;, DEV_NAME); return 0; } // 驱动出口 static void __exit my_exit(void) { device_destroy(my_class, dev_num); class_destroy(my_class); cdev_del(\u0026amp;my_cdev); unregister_chrdev_region(dev_num, 1); printk(\u0026#34;驱动日志: 驱动卸载成功\\n\u0026#34;); } module_init(my_init); module_exit(my_exit); MODULE_LICENSE(\u0026#34;GPL\u0026#34;); 2. 测试应用程序 (app_test.c) # 为了验证效果，我们可以运行两个这个程序的实例。\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main(int argc, char *argv[]) { if (argc != 2) { printf(\u0026#34;用法: ./app \u0026lt;要写入的字符串\u0026gt;\\n\u0026#34;); return -1; } int fd = open(\u0026#34;/dev/test_private\u0026#34;, O_RDWR); if (fd \u0026lt; 0) { perror(\u0026#34;打开失败\u0026#34;); return -1; } char write_buf[128]; char read_buf[128] = {0}; // 1. 写入用户传入的字符串 strncpy(write_buf, argv[1], 128); printf(\u0026#34;[APP] 正在写入: %s\\n\u0026#34;, write_buf); write(fd, write_buf, strlen(write_buf)); // 2. 模拟一段长时间的等待，为了让我们有时间去运行另一个APP printf(\u0026#34;[APP] 写入完成。现在睡眠10秒...\\n\u0026#34;); printf(\u0026#34;[APP] 请赶紧去另一个终端运行 ./app \u0026lt;其他字符串\u0026gt; 来测试干扰！\\n\u0026#34;); sleep(10); // 3. 醒来后读取数据 printf(\u0026#34;[APP] 醒来了，准备读取...\\n\u0026#34;); read(fd, read_buf, 128); printf(\u0026#34;[APP] 读取到的内容: %s\\n\u0026#34;, read_buf); // 4. 验证 if (strcmp(write_buf, read_buf) == 0) { printf(\u0026#34;[APP] 测试成功！数据没被别人覆盖。\\n\u0026#34;); } else { printf(\u0026#34;[APP] 测试失败！数据被别人篡改了！\\n\u0026#34;); } close(fd); return 0; } 🧪 实验步骤（见证奇迹的时刻） # 请在板子上打开 两个 终端窗口。\n加载驱动：\ninsmod private_data_drv.ko 在 终端 A 运行 APP（写入 \u0026ldquo;AAAAA\u0026rdquo;）：\n./app AAAAA 它会提示你：“写入完成，睡眠 10 秒\u0026hellip;”\n迅速在 终端 B 运行 APP（写入 \u0026ldquo;BBBBB\u0026rdquo;）：\n./app BBBBB 它也会写入并睡眠。\n观察结果：\n如果用的是 全局变量： 终端 A 醒来后，读到的会是 \u0026ldquo;BBBBB\u0026rdquo;（因为被后来者覆盖了）。 如果用的是 private_data（上面的代码）： 终端 A 醒来，读到的一定是 \u0026ldquo;AAAAA\u0026rdquo;。 终端 B 醒来，读到的一定是 \u0026ldquo;BBBBB\u0026rdquo;。 🔍 为什么会这样？（底层逻辑） # 终端 A 运行 ./app -\u0026gt; 调用 open -\u0026gt; 驱动 kmalloc 了一块内存（假设地址 0x1000），挂在 A 的 file-\u0026gt;private_data 上。 终端 B 运行 ./app -\u0026gt; 调用 open -\u0026gt; 驱动 又 kmalloc 了一块新内存（假设地址 0x2000），挂在 B 的 file-\u0026gt;private_data 上。 A 写数据，写到了 0x1000。 B 写数据，写到了 0x2000。 A 读数据，驱动从 A 的 file 里取出 0x1000，读出 \u0026ldquo;AAAAA\u0026rdquo;。 这就实现了完美的数据隔离。这就是 Linux 驱动支持多用户并发访问的基础！\n新增：官方文档私有数据处理方法 # （知识点：把全局变量打包，并通过指针传递） struct device_test dev1定义在函数外面，是全局变量。编译的时候内存就分配好了，一直在那儿。\n做法 # 打包：他不再零散地定义 dev_t dev_num、struct cdev、char kbuf[]，而是定义了一个大结构体 struct device_test，把所有跟这个设备有关的东西都塞进去。并且定义了一个全局变量 struct device_test dev1;。 挂接：在 open 函数里，他执行了 file-\u0026gt;private_data = \u0026amp;dev1;。意思是：把这个全局变量的地址挂在这个文件指针上。 使用：在 write 函数里，他不再直接使用全局变量名 dev1.kbuf，而是先取出指针 test_dev = file-\u0026gt;private_data，再用 test_dev-\u0026gt;kbuf 来操作。 why（为什么不直接用全局变量 dev1？） # 虽然在这个特定的简单例子里，直接用 dev1.kbuf 和用 private_data 效果一模一样，但他的目的是为了规范化（面向对象思维）。\n优点 # 如果将来你的板子上有 2 个完全一样的设备（比如 dev1 和 dev2）。\n如果不使用 private_data：你需要写两套 write 函数（write_for_dev1 和 write_for_dev2），或者在函数里写大量的 if/else。 如果使用 private_data：你的 write 函数一行都不用改！ 打开 dev1 时，private_data 指向 \u0026amp;dev1。 打开 dev2 时，private_data 指向 \u0026amp;dev2。 write 函数只管操作指针，不管具体指向谁。 总结官方代码： 它是静态的用法。它主要解决的是**“驱动代码通用性”**的问题，让一套操作函数能服务于特定的硬件对象。\n区别对比表 # 特性 官方代码 (全局变量 \u0026amp;dev1) 第五关 (kmalloc) 内存来源 全局静态区 (编译时决定) 堆区 (运行时动态申请) 多 App 打开 共享同一个空间 数据完全隔离 比喻 公园的长椅 (大家坐同一把椅子) 酒店的房间 (每人开一间房) 适用场景 硬件控制 (比如 LED、GPIO) 软件缓冲区 (比如虚拟串口、独立存储) 场景还原：如果两个 APP 同时打开设备 # 官方代码的情况：\nAPP A 打开设备 -\u0026gt; private_data 指向 \u0026amp;dev1。 APP B 打开设备 -\u0026gt; private_data 指向 \u0026amp;dev1。 结果：A 和 B 操作的是同一块内存。A 写进去的数据，B 能读到；B 写进去的数据，也会覆盖 A 的数据。 为什么这样设计？ 因为对于硬件来说，物理上只有一个。比如板子上只有一个 LED 灯，无论 A 还是 B 来控制，控制的都是同一个物理寄存器。所以这里的 dev1 代表的是那个唯一的物理实体。 第五关代码 (kmalloc) 的情况：\nAPP A 打开设备 -\u0026gt; kmalloc 申请了内存块 A -\u0026gt; private_data 指向 A。 APP B 打开设备 -\u0026gt; kmalloc 申请了内存块 B -\u0026gt; private_data 指向 B。 结果：A 和 B 操作的是不同的内存。互不干扰。 为什么这样设计？ 这种通常用于纯软件驱动或者需要每个用户独立上下文的场景（比如每个连接都要有独立的接收缓冲区）。 第六关：使用 goto 跳转到错误处理处 # 你好！这一节的内容非常实战，也是区分“写着玩”和“工业级代码”的重要标准。\n在 Linux 内核里，资源（内存、设备号、节点等）是非常宝贵的。如果你的驱动加载到一半失败了，却不把之前申请的资源还回去，就会造成资源泄漏（Resource Leak）。久而久之，系统就会因为资源耗尽而崩溃。\n🏰 通俗比喻 # 假设你的驱动程序初始化（init）就像勇者要去城堡见国王，必须连过三道关卡：\n第一关：申请设备号（拿通行证）。 第二关：注册 cdev（登记身份）。 第三关：创建设备节点（进入大殿）。 ❌ 如果没有错误处理（耍流氓） # 你过了第一关（拿到通行证）。 你过了第二关（登记了身份）。 第三关失败了（大殿门锁坏了，进不去）。 结果：你直接转身回家了。 后果：由于你没退还通行证，也没注销身份，城堡名册里一直有你，但实际上你人不在。下次再来申请，管理员说：“你不是已经在里面了吗？”——这就是资源泄漏/冲突。 ✅ 正确的错误处理（倒叙撤销） # 第三关失败时：你不能直接回家。你必须倒着走回去。 处理： 先去第二关，注销身份。 再去第一关，退还通行证。 最后才能回家报错。 🛠️ 为什么要用 goto？ # 在 C 语言里，如果有 5 个步骤，用 if-else 层层嵌套会写出“代码金字塔”，非常难看且容易出错。 Linux 内核约定俗成：使用 goto 语句跳转到统一的错误处理代码段。\n核心口诀：先进后出（FILO）\n第 1 个申请的资源，要在 最倒霉（最后一步才出错）的时候才释放，所以它的释放代码放在最下面。 第 3 个申请的资源，如果在第 4 步出错，它是第一个需要被释放的。 💻 代码实战：带错误处理的驱动框架 # 请仔细看下面代码中的注释，特别是 goto 跳转的位置和标号的顺序。\n#include \u0026lt;linux/init.h\u0026gt; #include \u0026lt;linux/module.h\u0026gt; #include \u0026lt;linux/fs.h\u0026gt; #include \u0026lt;linux/cdev.h\u0026gt; #include \u0026lt;linux/device.h\u0026gt; #include \u0026lt;linux/err.h\u0026gt; // 必须包含，用于 IS_ERR 和 PTR_ERR static dev_t dev_num; static struct cdev my_cdev; static struct class *my_class; static struct device *my_device; static int __init my_driver_init(void) { int ret; // --- 第一关：申请设备号 --- ret = alloc_chrdev_region(\u0026amp;dev_num, 0, 1, \u0026#34;error_test_dev\u0026#34;); if (ret \u0026lt; 0) { printk(\u0026#34;第一关失败：申请设备号挂了\\n\u0026#34;); // 第一关就挂了，之前啥也没干，直接返回错误，不需要 goto return ret; } // --- 第二关：注册 cdev --- cdev_init(\u0026amp;my_cdev, NULL); // 这里省略fops仅做演示 ret = cdev_add(\u0026amp;my_cdev, dev_num, 1); if (ret \u0026lt; 0) { printk(\u0026#34;第二关失败：cdev注册挂了\\n\u0026#34;); // 这里失败了，需要把第一关申请的设备号还回去 goto free_dev_num; } // --- 第三关：创建类 --- my_class = class_create(THIS_MODULE, \u0026#34;test_class\u0026#34;); // 注意：class_create 返回的是指针，判断指针错误要用 IS_ERR if (IS_ERR(my_class)) { printk(\u0026#34;第三关失败：创建类挂了\\n\u0026#34;); ret = PTR_ERR(my_class); // 把指针错误转换成错误码(int) // 这里失败了，要撤销第二关(cdev)和第一关(设备号) goto del_cdev; } // --- 第四关：创建设备节点 --- my_device = device_create(my_class, NULL, dev_num, NULL, \u0026#34;test_device\u0026#34;); if (IS_ERR(my_device)) { printk(\u0026#34;第四关失败：创建设备节点挂了\\n\u0026#34;); ret = PTR_ERR(my_device); // 这里失败了，要撤销第三关(类)、第二关(cdev)、第一关(设备号) goto destroy_class; } printk(\u0026#34;恭喜！所有关卡全部通过！\\n\u0026#34;); return 0; // =========================================== // 下面是“倒叙”的错误处理区 // =========================================== destroy_class: // 撤销第三关 class_destroy(my_class); del_cdev: // 撤销第二关 cdev_del(\u0026amp;my_cdev); free_dev_num: // 撤销第一关 unregister_chrdev_region(dev_num, 1); // 返回错误码给内核，告诉它加载失败 return ret; } static void __exit my_driver_exit(void) { // 正常卸载时的顺序，和错误处理是一样的：倒着拆 device_destroy(my_class, dev_num); class_destroy(my_class); cdev_del(\u0026amp;my_cdev); unregister_chrdev_region(dev_num, 1); printk(\u0026#34;驱动安全卸载\\n\u0026#34;); } module_init(my_driver_init); module_exit(my_driver_exit); MODULE_LICENSE(\u0026#34;GPL\u0026#34;); 🔍 关键知识点解释 # 标签（Label）命名规范：\n标签名通常代表**“在这个地方要做什么清理工作”**。 例如 destroy_class: 意味着跳到这里是为了销毁 class。 也有人喜欢命名为 err_step3，看个人习惯，建议用动词更清晰。 执行流（瀑布流）：\n注意看 destroy_class: 下面没有 break 也没有 return。 这意味着，如果代码跳到了 destroy_class，它执行完 class_destroy 后，会接着往下执行 del_cdev，再接着执行 free_dev_num。 这正是我们想要的！因为如果在第 4 步出错，第 3、2、1 步申请的资源都需要释放。 IS_ERR 和 PTR_ERR：\n有些函数（如 class_create）返回的是指针。如果失败了，它不会返回 NULL，而是返回一个特殊的“错误指针”（比如地址 0xFFFFFFF0）。 判断方法：必须用 IS_ERR(ptr) 来判断是否出错。 获取错误码：必须用 PTR_ERR(ptr) 把这个指针翻译成 -ENOMEM 之类的整数错误码返回给 ret。 (原因)传递真相：上层系统（比如 insmod 命令）接收到 ret 返回的 -12 后，它会查表，然后并在屏幕上打印出精美的报错信息：\u0026ldquo;Out of memory\u0026rdquo;（而不是仅仅显示“加载失败”）。 类型转换：my_class 是指针变量，ret 是整数变量。C 语言中，指针不能直接赋值给整数，必须通过 PTR_ERR 进行强制类型转换并还原数值。 🚀 总结 # 这一节的核心就是学会写**“后悔药”**： 只要前面的步骤成功了，当前步骤失败了，就必须用 goto 跳到对应的错误处理段，把之前吃进去的资源全部吐出来。\n","date":"17 November 2025","externalUrl":null,"permalink":"/notes/linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91_%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87/","section":"Notes","summary":"","title":"Linux驱动开发 字符设备","type":"notes"},{"content":" Linux 驱动的分类 # 字符设备驱动（重要 ）：IO 的传输过程是以字符为单位的，没有缓冲。比如 I2C,SPI 都是字符设备 块设备驱动：IO 的传输过程是以块为的单位的。与存储相关，如：tf 卡 网络设备驱动：与前两个不同，都是以 socket 套接字节来访问的 驱动四个部分 # 头文件 驱动模块的入口和出口 声明信息 功能实现 编译驱动 # 编译驱动的两种方法 # 将驱动编译成内核模块 将驱动编译进内核 把驱动编译成内核模 # 参考文章：D:\\Wechatfile\\WeChat Files\\wxid_jdbkf3gcd0e422\\FileStorage\\File\\2025-11\\【北京迅为】itop-3568 开发板驱动开发指南（重制版）1.8.pdf 第三章 内核模块实验\n写.c 文件和 Makefile 文件在同于一个文件夹下面 export ARCH=arm64 #设置交叉编译器前缀，依据具体开发板对应的交叉编译器前缀选择。 export CROSS_COMPILE=aarch64-linux-gnu- #生成 helloworld.o 文件。helloworld.o 名称要与 helloworld.c 驱动名称保持一致。 obj-m += helloworld.o #内核源码所在虚拟机 ubuntu 的实际路径，并且保证该路径下的内核源码已经编译通过，否则编译驱动会出现报错。具体编译方法请参考对应开发板使用手册，如 iTOP-RK3568 开发板编译手册。 KDIR :=/home/kernels/linux_sdk/kernel PWD ?= $(shell pwd) all: make -C $(KDIR) M=$(PWD) modules #make 操作 clean: make -C $(KDIR) M=$(PWD) clean #make clean 操作 编译为内核模块 输入 make 命令即可把 helloworld 驱动编译成内核模块 内核模块是以 ko 为后缀名，因此编译成功得到的 helloworld.ko 文件即内核模块，也就是编译好的驱动程序 make clean 命令可以清除编译文件 模块加载与卸载 将 helloworld.ko 内核模块拷贝到 iTOP-RK3568 开发板上,使用： insmod helloworld.ko 查看加载的模块\nlsmod 命令加载 helloworld 内核模块，会执行驱动入口函数；\nrmmod helloworld.ko 执行 rmmod helloworld 命令会希望在内核模块，在卸载内核模块的时候会执行驱动出口函数\n验证设备节点是否创建成功 在终端里输入以下命令： ls -l /dev/hello_misc # 这里的hello_misc是结构体里面的名字 如果成功，你会看到类似 crw-rw-rw- 1 root root 10, 58 Nov 13 10:00 /dev/hello_misc 的输出。 开头的 c 代表它是一个字符设备 (Character Device)。 10, 58 是它的主设备号 (Major Number) 和次设备号 (Minor Number)。所有 misc 设备的主设备号都是 10。 如果失败，提示“No such file or directory”，说明你的驱动加载可能有问题。这时应该用 dmesg 命令查看内核日志。\n与设备进行交互 (有的话才操作 触发你的驱动代码) 假设你的 misc_fops 结构体里定义了 read 和 write 函数：\n测试 write 函数： 使用 echo 命令向设备文件“写入”数据。这个操作会触发你驱动里的 write 函数。 # 需要root权限才能写入 sudo echo \u0026#34;some test data\u0026#34; \u0026gt; /dev/hello_misc 测试 read 函数： 使用 cat 命令从设备文件“读取”数据。这个操作会触发你驱动里的 read 函数。 cat /dev/hello_misc 查看内核打印信息 (最重要的调试手段) 你的 read 和 write 函数里，一定有 printk 语句吧？printk 的信息不会显示在你的当前终端里，而是被放到了内核的环形缓冲区中。你需要用 dmesg 命令来查看它们。\n# 执行完 echo 或 cat 操作后，立刻执行 dmesg dmesg 你应该能在 dmesg 输出的末尾，看到你在 write 或 read 函数中用 printk 打印出来的信息，例如：\n[12345.67890] hello_misc_write called! Received 15 bytes. [12345.98765] hello_misc_read called! 看到这些打印，就证明你的驱动代码确实被成功调用了！\n卸载驱动： sudo rmmod 1_misc # (注意，卸载时用模块名，不带.ko) Linux 下编译驱动实践 USB 转串口 # make menuconfig 图形化配置 # 在内核源码路径下输入：make menuconfig 即可打开图形化界面（内核源码：/home/kernels/linux_sdk/kernel）\nmake menuconfig 图形化配置的操作 输入\u0026quot;/\u0026ldquo;即可弹出搜索界面，然后输入想搜索的内容\n配置驱动状态 (1) 将驱动编译成内核模块 M (2) 将驱动编译进内核 * (3) 不编译 使用空格按键配置这三种状态\nmake menuconfig 有关文件 Makefile：编译规则，告诉我们在 make 的时候要怎么编译 菜的做法 Kconfig:内核配置选项 菜单 .confiig: 配置完内核以后生成的配置选项 点完菜\nmake menuconfig 会读取目录下的 Kconfig 文件 Arch/\u0026amp;ARCH/目录下的 Kconfig\n内核源码/arch/arm/configs 下面有很多配置文件，相当于特色菜\n为何将/arch/arm/configs 下的文件复制为.config 到 内核源码/.config 而不复制成其他文件 内核默认读取.config 作为默认配置选项\n复制的默认配置不符合要求怎么办？ 我们就要点菜，菜单是 Kconfig，通过 make menuconfig 来调出这个菜单，配置完以后自动更新到.config\n如何与 Makefile 文件建立联系？ 当 make menufig 保存退出之后，Linux 会将所有的配置选项以宏定义的形式保存在 include/generated/下面的 autocon.h 里面\n与图形化相关的文件 # Kconfig:内核配置选项 菜单 Kconfig 文件是图形化配置界面的的源文件，图形化配置界面中的选项由 Kconfig 文件决定。当我们执行命令 make menuconfig 命令的时候，内核的配置工具会读取内核源码目录下的 arch/xxx/Kconfig。xxx 是命令 export ARCH=arm 中的 ARCH 的值。然后生成对应的配置界面供开发者使用。 config 文件和.config 文件 config 文件和.config 文件都是 Linux 内核的配置文件 config 文件位于 Linux 内核源码的 arch/S(ARCH)/configs （arch/arm64/configs）目录下，是 Linux 系统默认的配置文件，要使用默认，操作：make config_ 具体名字,这样就会生成.config .config 文件位于 Linux 内核源码的顶层目录下，编译 linux 内核时会使用.config 文件里面的配置来编译内核镜像。 若.config 存在，make menuconfig 界面的默认配置即当前.config 文件的配置，若修改了图形化配置界面的设置并保存，则.config 文件会被更新若.config 文件不存在，make menuconfig 界面的默认配置则为 Kconfig 文件中的默认配置使用命令 make xxx defconfig 命令会根据 arch/$(ARCH)/configs 日录下默认文件生成.config 文件。 Makefile 文件 Makefile 文件里面包含了编译规则，告诉我们要如何编译 Linux。 Kconfig 语法 # 详细请见：D:\\study file\\PDF\\16_开发板学习教程（重要）\\【北京迅为】itop-3568 开发板驱动开发指南 v1.8.pdf 第七章 7.3\n主菜单 配置选项 依赖关系 可选择项 source 把驱动编译进内核 # 以 helloworld 为例\n进入 drivers，这里面存放的是驱动。进入 char 目录下，这里存放的是字符设备。可以将 helloworld 存放到此。在这里面创建一个 hello 文件夹，里面创建一个 Kconfig 想要在图形化界面里面添加 helloworld 选项 在 char 目录下的 Kcongfig 要将 hello 里面的 Kconfig 包含进去 source \u0026#34;drivers/char/hello/Kconfig\u0026#34; 将写好的 helloworld.c 文件放入 hello 文件夹 编译之前创建 Makefile，要让 Makefile 与图形化界面产生联系。进入内核源码目录查看.config 文件，复制（）CONFIG_helloworld. obj-$(CONFIG_helloworld) += helloworld.o obj-y += hello/ 验证 在内核源码目录下有.config 文件，而默认的.config 在内核源码下的 arch/arm64/configs 下的 rockchip_linux_deconfig，要是使用 make，生成新的.config 会覆盖 hello 下的.config 而无法编译。故需要将默认的.config 用 hello 的.config 替换掉 cp .config arch/arm64/configs/rockchip_linux_deconfig 编译内核镜像 ./build.sh kernel hello 文件下生成了中间文件\n烧写内核源码下的 boot.img 文件到开发板\ndmesg | grep \u0026#34;hello\u0026#34; 查看是否找到\n视频没看懂思密达\u0026hellip;\u0026hellip;等学上几节再回来看\n杂项设备 # 是字符设备的一种。可以自动生成设备节点；可以通过 cat /proc/misc 命令来查看\n杂项设备除了比字符设备代码简单，是否还有别的区别？ 杂项设备的主设备号是相同的，均为 10，次设备号是不同的。主设设备号相同就可以节 省内核的资源。\n主设备号和次设备号是什么？ 设备号包含主设备号和次设备号，主设备号在 Linux 系统里面是唯一的，次设备号不一定唯一。 设备号是计算机识别设备的一种方式，主设备相同的就被视为同一类设备。 主设备号可以比做成电话号码的区号。比如北京的区号是 010 ，次设备号可以比作成电话号码。 主设备号可以通过命令 cat /proc/devices\n杂项设备的描述 定义在内核源码路径下的：include/linux/miscdevice.h\nstruct miscdevice { int minor; //次设备号 const char *name; //设备的节点的名字 const struct file_operations *fops; //文件操作集 struct list_head list; struct device *parent; struct device *this_device; const struct attribute_group **groups; const char *nodename; umode_t mode; }; extern int misc_register(struct miscdevice *misc); //注册杂项设备 extern void misc_deregister(struct miscdevice *misc); //注销杂项设备 file_operation 文件操作集在定义在 include/linux/fs.h 下面，里面的的一个结构体成员对应一个调用 注册杂项设备流程\n填充 miscdevice 结构体 填充 file_operation 这个结构体 注册杂项设备并生成设备节点 驱动层传参 # 传参类型：\n基本类型：module_param 数组：module_param_array 字符串：module_param_string 位置：/home/kernels/linux_sdk/kernel/include 内核符号表 # B 模块使用 A 模块中的函数 A:里面要有 EXPORT_SYMBOL(函数)，这个函数是你 B 文件中要使用的函数/变量。EXPORT_SYMBOL(add); B:声明你要是用的 A 里面的函数/变量。extern int add(int a, int b); 因为 B 里面用了 A 函数，所以要先编译 A 如果两个.c 在同一个目录下面：Makefile 中记得两个文件都要添加 obj-m 如果两个.c 不在同一个目录下面：编译完 A 之后生成的 Module.sumvers（符号表）要复制到与 B 同目录下\n应用层和内核层数据传输 # 编译进内核的驱动如何运行 # 一路跳转\n#define module_init(x)\t__initcall(x); #define __initcall(fn) device_initcall(fn) #define device_initcall(fn)\t__define_initcall(fn, 6) #define __define_initcall(fn, id) ___define_initcall(fn, id, .initcall##id) #else #define ___define_initcall(fn, id, __sec) \\ static initcall_t __initcall_##fn##id __used \\ __attribute__((__section__(#__sec \u0026#34;.init\u0026#34;))) = fn; // 例如，当 fn=hello_world、id=6、__sec=subsys 时，展开后为： static initcall_t __initcall_hello_world6 __used __attribute__((__section__(\u0026#34;subsys.init\u0026#34;))) = hello_world; 作用：是将函数注册为内核初始化过程的一部分，在系统启动时按特定优先级执行\nLinux 内核启动过程需要执行大量初始化函数（如驱动初始化、子系统初始化等），这些函数通过不同的 initcall 宏注册，并按优先级分阶段执行：\n内核定义了一系列封装好的宏（如 module_init、core_initcall、late_initcall 等），最终都会调用 **_define_initcall，并传入不同的 id 和 **sec 来控制执行顺序（id 越小，优先级越高，越早执行）。 链接器会将所有 xxx.init 段的函数指针按顺序排列，内核启动时遍历这些指针并调用对应的函数，实现有序初始化。 ___define_initcall 是内核初始化机制的 “注册器”，通过函数指针和自定义链接段的结合，让内核能在启动时自动、按序执行所有注册的初始化函数。这也是驱动代码中 module_init(my_init) 能生效的底层原理（module_init 是对该宏的高层封装）。\n后半段没听懂 对应文件：D:\\Wechatfile\\WeChat Files\\wxid_jdbkf3gcd0e422\\FileStorage\\File\\2025-11\\【北京迅为】itop-3568 开发板驱动开发指南（重制版）1.8.pdf\n\u0026hellip;\u0026hellip;未完待续\n","date":"11 November 2025","externalUrl":null,"permalink":"/notes/linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91_%E5%85%A5%E9%97%A8%E7%AF%87/","section":"Notes","summary":"在这里写下您的文章摘要\u0026hellip;","title":"Linux驱动开发 入门篇","type":"notes"},{"content":"","date":"6 November 2025","externalUrl":null,"permalink":"/tags/linux/","section":"Tags","summary":"","title":"Linux\"","type":"tags"},{"content":"视频：(【北京迅为】嵌入式学习之 Linux 系统编程篇)[https://www.bilibili.com/video/BV1zV411e7Cy?vd_source=de9d0b5f46420ead2e7be875b9558767\u0026amp;spm_id_from=333.788.videopod.episodes] 文档：【北京迅为】itop-3568 开发板系统编程手册（新）.pdf\n介于应用层和驱动层之间\n可以在 Linux 系统下完成基本操作 完成入门教程（视频文档都可） 视频：(【北京迅为】嵌入式学习之 Linux 入门篇)[https://www.bilibili.com/video/BV1M7411m7wT/?spm_id_from=333.1387.upload.video_card.click\u0026amp;vd_source=de9d0b5f46420ead2e7be875b9558767] 文档：【北京迅为】itop-3568ubuntu 使用手册.pdf\n01*【北京迅为】itop-3568 开发板快速启动手册【底板 v1.7 版】v1.1.pdf\n03*【北京迅为】itop-3568 开发板快速使用编译环境 ubuntu18.04【底板 v1.7】 v1.1.pdf\nmain 函数传参\nint main(int argc, char *argv[]) { /* 代码 */ } argc 英文全称为 argument count，表示命令行参数的数量。 argv 英文全称为 argument value，是一个指向字符串数组的指针，每个字符串表示一个命 令行参数。\n文件 IO/标准 IO 文件：直接 标准：间接\n文件 IO # 文件描述符 fd = open()\nopen-打开文件\nint open(const char *pathname, int flags); int open(const char *pathname, int flags, mode_t mode); close-关闭文件 read-读文件\n- ssize_t read(int fd, void \\*buf, size_t count); 返回实际读到的字节数 如果读到文件末尾，返回 0 如果读错，返回-1 write-写文件\nssize_t write(int fd, const void *buf, size_t count); 如果要写一个文件的内容，count 可以是读文件的返回值（ret = read(),write(,,ret)）,因为读文件返回的就是字节大小，相当于写了 buf 中所有东西 在 Ubuntu 中运行： gcc \u0026lt;文件名\u0026gt;.c #编译 生成.out 文件 ./文件名.out\nlseek\noff_t lseek(int fd, off_t offset, int whence); // whence 参数 // SEEK_SET：相对于文件开头 // SEEK_CUR:相对于当前的文件读写指针位置 // SEEK_END:相对于文件末尾 lseek(fd,0,SEEK_END); //指针在文件末尾 返回文件总字节大小 lseek(fd,0,SEEK_CUR) //返回当前指针所在位置之前的字节大小 返回当前位移大小 目录 IO # 创建目录\nint mkdir(const char *pathname, mode_t mode); 打开、关闭目录\nDIR *opendir(const char *name); //失败返回 NULL 成功返回打开的目录流 int closedir(DIR *dirp); //调用成功返回 0，调用失败返回-1 读取目录\nstruct dirent *readdir(DIR *dirp); // 成功返回指向 dirent 类型结构体的指针 失败返回 NULL 文件在目录下面是通过链表存放的，要查看所有需要循环读取\n库 # 静态库：在程序编译的时候会被链接到目标代码里 程序运行不需要该静态库 编译出来体积大 静态库以 lib 开头 以.a 结尾 eg.移植 动态库：也叫共享库 编译的时候不会被链接到目标代码里，而是在运行的时候被载入的 程序运行需要该动态库 编译出来体积小 动态库以 lib 开头 以.so 结尾\n静态库制作\n编译或准备库的源代码 将源码.c 文件编译成.o 文件 （gcc -c 文件名.c） 使用 ar 命令创建静态库 （ar cr lib 文件名.a gcc wenjian .c -l 文件名 -L .） lib 文件名.a：库文件名 文件名：库名 测试库文件 (gcc test .c -l 文件名 -L . -l:指定静态库的库名 -L 查找位置 . :当前目录下面去查找 ) 动态库制作\ngcc -c -fpic 库名 .c //生成.o 文件 gcc -shared -o lib 库名.so 库名.o //生成 lib 库名.so\n如果我们的程序代码用到了库文件里面的函数，我们在编译的时候需要链接库。系统默认会在/ib 或者/usr/lib 去找库文件。如果我们使用的库不在里面，会提示错误 解决方法：\n将生成的动态库拷贝到/ib 或者/usr/lib 里面去，因为系统会默认去这俩个路径下寻找。 把我们的动态库所在的路径加到环境变量里面去（只对当前终端有效） 比如我们动态库所在的路径为/home/test，我们就可以这样添加： export LD LIBRARY PATH=$LD LIBRARY PATH:/home/test 修改 ubuntu 下的配置文件/etc/ld.so.conf，在这个配置文件里面加入动态库所在的位置，然后使用命令 ldconfig 更新目录。 gcc -c -fpic 库名 .c //生成.o 文件 gcc -shared -o lib 库名.so 库名.o //生成 lib 库名.so\n进程 # 当程序在 Linux 操作系统中运行起来之后就变成了进程 进程 ID 每个进程都有唯一标识符，即进程 ID，简称 pid\n进程间的几种通信方法 管道通信:有名管道，无名管道 信号通信:信号的发送，信号的接受，信号的处理 IPC 通信:共享内存，消息队列，信号灯 Socket 通信\n创建进程函数\npid_t fork(void); 返回值为 0，则说明当前进程是子进程 返回值大于 0，则说明当前进程是父进程，返回值为子进程的进程 ID 返回值小于 0，则说明 fork() 函数调用失败。 getpid()函数的作用为获取当前进程 pid getppid()函数的作用为获取当前进程父进程的 pid exec 函数族\n在 Linux 中使用 exec 函数族主要有以下两种情况：\n当进程认为自己不能再为系统和用户做出任何贡献时，就可以调用任何 exec 函数族让自己重生。 如果一个进程想执行另一个程序，那么它就可以调用 fork 函数新建一个进程，然后调用任何一个 exec 函数使子进程重生。 int execl(const char *path, const char *arg,..) // 将新程序加载到当前进程空间中（新创建的（fork）进程），替换原来的程序映像(执行path arg 程序，而非源程序)，并传递参数列表 int execv(const char *path, char *const argv[]) int execle(const cha *path,const char*arg,...,char *const envp[]) int execve(const char *path, char *const argv[], char *const envp[]) int execlp(const char *file,const char *arg, ...) int execvp(const char *file,char *const argv[]) ps 和 kill 命令\nps:查看进程信息\nps [options] // a 显示所有进程信息，包括其他用户的进程 // x 显示所有进程，包括没有控制终端的进程 // u 显示用户及资源使用情况 // e 显示所有进程信息，包括没有控制终端的进程，和 x 选项相比没有进程状态 // f 以进程树的形式显示进程信息 // w 使用宽输出格式，以便完整地显示进程信息 // h 不显示标题行 // o 自定义输出格式，可以指定输出的列和列之间的分隔符 kill 进程：向指定的进程发送信号，以达到控制进程行为的目的\nkill [signal] PID 孤儿进程 孤儿进程是指其父进程先于它结束，从而没有父进程来对它进行资源回收和管理的进程。当进程变为孤儿进程之后，会被进程 init 进程领养\n僵尸进程\n在操作系统中，每个进程都有一个唯一的进程 ID，以及父进程 ID。当一个进程终止时，它的进程 ID 和状态信息会被保留在系统中，从而方便父进程的查询。 而僵尸进程（zombie）是指已经执行完毕，但是父进程没有及时回收其资源的进程\nwait 函数\npid_t wait(int *status); 父进程可以通过 wait()函数等待子进程完成某些任务，然后再继续执行自己的任务。此外，子进程可以通过 exit()函数的返回值来向父进程传递处理结果或者状态\n守护进程 daemon 运行再后台，不和任何控制终端关联 两个基本要求：\n作为 init 进程的子进程\n不和控制终端交互\n使用 fork 函数创建一个新的进程，让父进程直接退出（exit 函数） 使得子进程成为孤儿进程 （必须）\n调用 setsid 函数，让其摆脱控制终端 创建新的会话 （必须）\n调用 chdit 函数，将当前的工作目录改变为根目录，增强程序健壮性\n重设 umask 文件掩码，增强程序健壮性和灵活性\n关闭 0，1，2 文件描述符，节省资源 close(0)\u0026hellip;\n执行需要执行的代码（必须）\n无名管道 只能通过文件描述符在具有亲缘关系的进程之间使用，如父子进程、兄弟进程等 在 fork 函数之前创建管道 pipe(fd)\n有名管道 实现两个互不相关的进程间的通信 知道特殊文件路径，可以读写\n信号通信-信号发送\nint kill(pid_t pid, int sig); int raise(int sig); // raise函数等价于kill(getpid(),sig); unsigned int alarm(unsigned int seconds); 信号通信-信号接收\nwhile(1) sleep() int pause(void); // 函数说明：pause(会令目前的进程暂停（进入睡眠状态）直到被信号(signal)所中断。返回值：只返回-1. 信号通信-信号处理\ntypedef void (*sighandler_t)(int); sighandler_t signal(int signum, sighandler_t handler); // signal（参数1,参数2）； // 参数1：我们要进行处理的信号，系统的信号我们可以再终端键入kill -l查看。 // 参数2：处理的方式（是系统默认还是忽略还是捕获）。 signal(SIGINT,SIG_IGN,); // SIG_IGN，代表忽略，也就是忽略 SIGINT 信号 signal(SIGINT,SIG_DFL); // SIG_DFL 代表执行系统默认操作，大多数信号的系统默认动作时终止该进程。 signal(SIGINT,myfun); //捕捉 SIGINT 这个信号，然后执行 myfun 函数里面的代码。myfun 由我们自己定义。 共享内存 # 创建或获取一个 IPC key\nkey_t ftok(const char *pathname, int proj_id); //文件路径 一个整数值 创建共享内存\nint shmget(key_t key, size_t size, int shmflg); //返回值为共享内存标识符（shmid），用于标识创建或获取的共享内存对象。如果出错，则返回 -1 并设置 errno 错误码 // key:使用 ftok()函数生成的 IPC key 值 非零 使用宏：0 //size:共享内存大小，以字节为单位 将共享内存映射到进程的地址空间中(效率高，不用每次进入内核)\nvoid *shmat(int shmid, const void *shmaddr, int shmflg); //shmid: 共享内存标识符，通过 shmget() 函数创建或获取。 //shmaddr:指定共享内存段的连接地址，通常设置为 NULL，让系统自动选择一个合适的地址。 //shmflg:连接共享内存的标志位 SHM_RDONLY SHM_RND SHM_REMAP 解除共享内存映射\nint shmdt(const void *shmaddr); //共享内存段的首地址 删除共享内存\nint shmctl(int shmid, int cmd, struct shmid_ds *buf); // shimid:shmget() 函数创建的共享内存标识符 // cmd: IPC_STAT(获取对象属性)IPC_SET(设置对象属性）IPCRMID（删除对象） // buf:指定IPC_STAT(获取对象属性)IPC_SET(设置对象属性）时用来保存或者设置的属性。 消息队列 # 创建或打开消息队列\nint msgget(key_t key, int msgflg); //key:ftok()函数生成的 IPC key 值 //函数调用成功，会返回一个非负整数表示消息队列的标识符（即消息队列的唯一标识），调用失败返回-1 ipcs -q //共享内存\nipcs -m //消息队列\n发送消息\nint msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg); 接收消息\nssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp,int msgflg); \u0026hellip;\u0026hellip;未完待续\n","date":"6 November 2025","externalUrl":null,"permalink":"/notes/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/","section":"Notes","summary":"","title":"Linux系统编程","type":"notes"},{"content":"","date":"6 November 2025","externalUrl":null,"permalink":"/tags/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/","section":"Tags","summary":"","title":"系统编程","type":"tags"},{"content":" 一些文件地址 # 我的内核源码路径 /home/kernels/linux_sdk/kernel （我的交叉编译器所在路径） IP 改变： # 这个表示我的 ip 是什么？为什么不是原来的 IP 了？\n解释： 截图中的 ifconfig 命令只显示了一个名为 lo 的网络接口\nlo 是什么？ lo 是 \u0026ldquo;loopback\u0026rdquo; 的缩写，也就是“本地环回接口”。这是一个特殊的、虚拟的网络接口，它不连接任何外部网络。它的唯一作用就是让这台机器可以和自己通信。\nIP 127.0.0.1 是什么？ 这是 lo 接口的固定 IP 地址，是一个预留地址，在全球范围内都代表“本机”或“localhost”。当您访问 127.0.0.1 时，数据包不会发送到网络上，而是直接在您的系统内部“绕一圈”回到您自己这里。它主要用于程序开发和系统测试。\n结论： 根据这张截图，您的虚拟机目前没有一个可用于外部网络的 IP 地址。它只有一个指向自己的内部地址 127.0.0.1\n“原来”的 IP 地址之所以不见了，是因为负责连接外部网络的物理或虚拟网卡（通常叫 eth0、ens33、enp0s3 等）目前没有被激活，或者没有成功从路由器（DHCP 服务器）获取到 IP 地址。 ifconfig 命令在默认情况下，通常只显示当前已激活并分配了 IP 地址的网络接口。既然它只显示了 lo，就说明您的主网卡处于“离线”状态。\n主要原因可能包括： 虚拟机网络适配器被禁用了：在 VirtualBox 或 VMware 等虚拟机软件的设置中，该虚拟机的网络适配器可能没有勾选“启用”或“连接”。 Linux 内部的网络服务未启动*：负责管理网络的系统服务（如 networking 或 NetworkManager）可能没有正常启动。 网络配置问题：您可能修改了网络配置文件，导致配置错误，无法自动获取 IP。 虚拟机网络模式问题：虚拟机软件的网络模式（如 NAT、桥接模式）设置不正确，或者您主机的网络环境发生了变化。 下一步该怎么办？（如何解决） 请按照以下步骤来排查和解决问题，这通常能解决 99%的情况： 第一步：查看所有网卡（包括未激活的） 打开虚拟机终端，输入一个更强大的命令。ifconfig 有些老旧了，我们用新的 ip 命令：\nip addr 或者使用 ifconfig 的 -a 参数：\nifconfig -a 这两个命令会列出所有的网络接口，无论它们是否激活。您应该会看到除了 lo 之外，还有一个类似 eth0 或 ens33 的网卡。请注意观察它的状态，很可能会显示 state DOWN （表示已关闭）。 第二步：检查虚拟机设置 关闭您的 Linux 虚拟机（正常关机）。 回到 VirtualBox 或 VMware 的主界面，选中您的虚拟机，点击“设置”。 找到“网络”选项卡。 确保“启用网络适配器”这个复选框是勾选的。 确保“连接方式”是您需要的模式（通常是“NAT 模式”或“桥接模式”）。对于初学者，NAT 模式通常是最省心的。 点击“确定”保存设置，然后重新启动虚拟机。 第三步：手动启动网卡和网络服务 如果重启后问题依旧，可以尝试在 Linux 内部手动操作。 首先，找到您的网卡名字（假设通过 ip addr 查到是 ens33）。 启动网卡：\nsudo ip link set ens33 up (请将 ens33 替换为您自己的网卡名) 重启网络管理服务（根据您的 Linux 发行版选择一个执行）： 对于较新的 Debian/Ubuntu/CentOS 系统:\nsudo systemctl restart NetworkManager 对于较老的 Debian/Ubuntu 系统:\nsudo systemctl restart networking 重新获取 IP 地址：\nsudo dhclient ens33 (同样，替换 ens33) 完成这些操作后，再次执行 ifconfig 或 ip addr，您应该就能看到您熟悉的那个 IP 地址了。\n设置交叉编译器环境，并进行交叉编译 # export PATH=/usr/local/arm64/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu/bin:$PATH aarch64-linux-gnu-gcc -o demo66_uart demo66_uart.c 最后将交叉编译生成的 demo66_uart 文件拷贝到/home/nfs 共享目录下即可\n共享目录生效 # \u0026hellip;\u0026hellip;未完待续\n","date":"4 November 2025","externalUrl":null,"permalink":"/posts/linux%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/","section":"Posts","summary":"Linux学习时遇到的问题总结","title":"Linux问题总结","type":"posts"},{"content":"","date":"4 November 2025","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"本文 Docker 使用场景：电脑 A 上所有环境已经安装好，想要电脑 B 运行电脑 A 中的东西\nDocker 是什么？ # 1. Docker：一个开放源代码的平台 # Docker 是一个开源平台，它可以让你将应用程序及其所有依赖项（如库、系统工具、代码和运行时）打包到一个标准化的单元中，这个单元被称为容器。 这样，无论在任何环境下，你的应用程序都能以相同的方式运行。\n2. 容器 (Container)：轻量级的运行环境 # 容器是一个轻量级、可独立运行的软件包，其中包含了运行某个应用所需的一切：代码、运行时、系统工具、系统库和设置。容器在运行时相互隔离，也与底层的主机系统隔离，确保了环境的一致性。\n3. 镜像 (Image)：创建容器的模板 # 镜像是创建 Docker 容器的只读模板。它包含了应用程序代码以及运行该应用程序所需的所有工具、库和依赖项。你可以把镜像看作是容器的“蓝图”或“菜谱”。当你运行一个镜像时，就会创建一个该镜像的实例，也就是一个容器。\n4. Dockerfile：构建镜像的说明书 # Dockerfile 是一个文本文档，其中包含了一系列用户可以执行的指令，用于自动构建 Docker 镜像。Docker 会读取 Dockerfile 中的指令来一步步构建镜像。\n5. Docker 与虚拟机的区别 # 为了更好地理解 Docker，我们可以将它与传统的虚拟机（VM）进行比较：\n特性 Docker 容器 虚拟机 (VM) 虚拟化级别 操作系统级别虚拟化，共享主机内核 硬件级别虚拟化，每个 VM 都有自己的完整操作系统 资源消耗 资源消耗 轻量级，占用资源少，启动速度快（毫秒级） 资源密集型，需要加载完整的操作系统，启动速度慢（分钟级） 隔离性 进程级别隔离，安全性相对较低 完全隔离，每个 VM 都是一个独立的系统，安全性高 大小 镜像通常较小（MB 级别） 虚拟机镜像通常很大（GB 级别） 简单来说，虚拟机是在模拟一台完整的计算机，而 Docker 容器更像是运行在现有操作系统上的一个被隔离的进程。\n第一步：下载与安装 # 在两台电脑上下载好 Docker，视频教程 [对应的文本教程}(https://github.com/tech-shrimp/docker_installer) (完成步骤 1，2 即可)\n下载完成后，打开终端，在两台电脑测试：\ndocker --version 如果能看到版本号，说明一切准备就绪。\n第二步： 运行第一个 Docker 容器 # 尝试拉取一个镜像，并且使用镜像运行交互式容器，最后尝试推出并且自动销毁一个容器。\n1.拉取（下载）一个镜像\n镜像是创建容器的模板。我们需要先从一个名为 Docker Hub 的公共镜像仓库中获取我们想要的镜像。Docker Hub 上存储了成千上万个官方和社区创建的镜像。 现在，拉取官方的 Ubuntu 镜像。在终端中输入以下命令：\ndocker pull ubuntu 下载完成后，可以使用以下命令查看你本地已经拥有的所有镜像：\ndocker images 2.运行（启动）一个容器 有了 ubuntu 镜像，就可以用它来创建一个容器了。这就像是用 Ubuntu 的安装盘（镜像）来启动一台新的电脑（容器）。\n在终端中输入以下命令：\ndocker run -it --rm ubuntu bash docker run: 这是运行一个容器的命令。 -it: 这是两个参数的组合： -i (\u0026ndash;interactive): 保持标准输入（STDIN）打开，允许你与容器进行交互。 -t (\u0026ndash;tty): 分配一个伪终端或终端。简单来说，就是让你能看到一个命令提示符。 -it，就是我们常说的“交互式终端”，它能让你像操作一台真实的 Linux 机器一样在容器里输入命令。 \u0026ndash;rm: 这个参数表示当容器退出时，自动将它删除。这对于我们进行快速测试非常方便，可以避免留下很多无用的容器。 ubuntu: 这是我们想要使用的镜像的名称。 bash: 这是我们希望在容器启动时执行的命令。bash 是 Ubuntu 系统中最常见的命令行 Shell。 当你执行完这条命令后，你会发现你的命令提示符变了！它可能看起来像这样：\nroot@xxxxxxxxxxxx:/# 现在已经在一个运行着 Ubuntu 的 Docker 容器内部了！ 这完全是在 Windows 系统上原生运行的，但你得到的却是一个隔离的、完整的 Ubuntu 文件系统和命令行环境。\n3. 在容器内进行交互\n可以在这个终端里尝试一些常见的 Linux 命令，感受一下： 查看当前目录下的文件： ls 查看操作系统版本： cat /etc/os-release 更新软件包列表： apt-get update\n4.退出容器 当完成实验后，只需在容器的终端里输入 exit 或者按下 Ctrl + D，就会退出这个容器。\n因为我们之前使用了 \u0026ndash;rm 参数，所以在你退出后，这个容器就被自动删除了。你可以通过 docker ps -a 命令来确认（-a会显示所有容器，包括已经停止的），会发现那个容器已经不见了。\n第三步：定制自己的环境 (Dockerfile) # Dockerfile 是一个文本文件，它像一份“安装说明书”，告诉 Docker 如何一步步地构建一个镜像。我们通过在其中写入指令（如安装软件、复制文件等）来定制我们的环境。\n核心指令 # FROM: 指定一个基础镜像，我们的构建将从这个镜像开始。例如 FROM ubuntu:22.04。 RUN: 执行一条命令。主要用于在镜像内部安装软件。例如 RUN apt-get update \u0026amp;\u0026amp; apt-get install -y python3。 WORKDIR: 设置工作目录，后续的指令都会在这个目录下执行。例如 WORKDIR /app。 COPY: 将你电脑上的文件或文件夹复制到镜像中。例如 COPY . . 表示将当前目录所有文件复制到镜像的当前工作目录。 CMD: 指定容器启动时默认执行的命令。例如 CMD [\u0026#34;bash\u0026#34;]。 操作任务 # 假设你的实验环境需要Python和Git。现在，我们在电脑 A 上创建一个包含这两个工具的自定义镜像 1.创建一个项目文件夹：在电脑 A 上，创建一个新的文件夹，例如 my-lab-env，然后进入这个文件夹。 2.创建 Dockerfile：在 my-lab-env 文件夹中，创建一个名为 Dockerfile (没有文件后缀) 的文件，用记事本或任何代码编辑器打开它，并输入以下内容：\n# 使用官方的Ubuntu 22.04作为基础镜像 FROM ubuntu:22.04 # 设置一个环境变量，避免安装时出现交互式提示 ENV DEBIAN_FRONTEND=noninteractive # 更新软件包列表，并安装python3, pip, 和 git # 使用 \u0026amp;\u0026amp; 连接命令，可以减小镜像层数 RUN sed -i \u0026#39;s/archive.ubuntu.com/mirrors.aliyun.com/g\u0026#39; /etc/apt/sources.list \u0026amp;\u0026amp; \\ apt-get update \u0026amp;\u0026amp; apt-get install -y \\ python3 \\ python3-pip \\ git \\ \u0026amp;\u0026amp; apt-get clean \u0026amp;\u0026amp; rm -rf /var/lib/apt/lists/* # 设置工作目录为 /app WORKDIR /app # 当容器启动时，默认执行bash命令，进入交互式终端 CMD [\u0026#34;bash\u0026#34;] 构建镜像：打开终端（PowerShell 或 CMD），确保正处于 my-lab-env 文件夹内。然后执行以下命令来构建第一个自定义镜像： # -t 参数用来给镜像命名和打标签，格式为 \u0026#39;名称:版本号\u0026#39; # \u0026#39;.\u0026#39; 表示Dockerfile在当前目录下 docker build -t my-lab-image:1.0 . 验证镜像：构建完成后，运行 docker images，看到刚刚创建的 my-lab-image:1.0。\n运行自定义容器：现在，用新镜像启动一个容器：\ndocker run -it --rm my-lab-image:1.0 进入容器后，可以分别输入 python3 --version 和 git --version 来验证软件是否已经成功安装。然后输入 exit 退出。\n第四步：让数据持久化 (Volumes) # 容器本身是“无状态”的，默认情况下，你在容器里做的所有文件修改都会随着容器的删除而消失。为了保存你的工作，我们需要使用数据卷 (Volume)。数据卷可以将主机上的一个文件夹映射到容器里的一个文件夹。这样，你在容器里对这个文件夹做的任何修改，都会实时同步到电脑的文件夹里，反之亦然。\n操作任务： # 在主机上创建工作区：在电脑 A 的 my-lab-env 文件夹内，再创建一个名为 workspace 的子文件夹。这个文件夹将用来存放项目代码。\n使用 -v 参数运行容器：现在，再次启动容器，但这次加上 -v 参数来挂载数据卷。\n# -v \u0026#34;你电脑上的绝对路径\u0026#34;:\u0026#34;容器内的绝对路径\u0026#34; # Windows CMD: docker run -it --rm -v \u0026#34;%cd%\\workspace:/app\u0026#34; my-lab-image:1.0 #若想把项目换成存放在 D:\\my_coding_projects\\robotics_simulation #则上面命令需要修改为：docker run -it --rm -v \u0026#34;D:\\my_coding_projects\\robotics_simulation:/app\u0026#34; my-lab-image:1.0 # Windows PowerShell: docker run -it --rm -v \u0026#34;${pwd}\\workspace:/app\u0026#34; my-lab-image:1.0 这个命令的意思是：将当前目录下的 workspace 文件夹，映射到容器内的/app 目录（在 Dockerfile 中设置的工作目录）。 验证数据持久化： 进入容器后，你现在正处于 /app 目录下。执行 ls，你会发现它是空的。 在容器内创建一个文件：echo \u0026ldquo;hello from container\u0026rdquo; \u0026gt; test.txt。 现在，不要退出容器，去你电脑的 my-lab-env\\workspace 文件夹下查看，你会惊喜地发现里面多了一个 test.txt 文件，内容正是你刚刚写入的！ 现在，在容器外，用记事本打开这个 test.txt，修改内容为 hello from host 并保存。 回到容器的终端，执行 cat test.txt，你会看到内容已经变成了 hello from host。 最后，输入 exit 退出并删除容器。但你电脑上 workspace 文件夹里的 test.txt 文件依然存在。你的工作被成功保存了！ 第五步：分享与同步你的环境 (Docker Hub) # Docker Hub 是一个公共的镜像注册中心，你可以把它想象成 Docker 镜像的 GitHub。你可以将你在本地构建的镜像推送到 Docker Hub，然后在世界上任何一台安装了 Docker 的机器上把它拉取下来。\n操作任务： # 注册 Docker Hub 账号：访问 https://hub.docker.com/ 并注册一个免费账号。记住你的用户名。 在电脑A上登录：打开终端，输入 docker login 命令，然后按照提示输入你的用户名和密码。 给镜像打上正确的标签：要将镜像推送到你的仓库，必须按照 你的用户名/镜像名:版本号 的格式重新给它打标签。 # docker tag \u0026lt;本地镜像名:版本号\u0026gt; \u0026lt;你的用户名/远程仓库名:版本号\u0026gt; docker tag my-lab-image:1.0 your-dockerhub-username/my-lab-env:1.0 推送镜像：现在，将你打好标签的镜像推送到 Docker Hub。 docker push your-dockerhub-username/my-lab-env:1.0 在电脑 B 上拉取镜像：现在，切换到电脑 B。 同样，先在终端执行 docker login 登录账号。 然后执行docker pull命令来拉取你刚刚推送的镜像： docker pull your-dockerhub-username/my-lab-env:1.0 第六步：网络连接 (Port Mapping) # 默认情况下，容器的网络是与外界隔离的。如果在容器里运行了一个需要通过浏览器访问的应用（比如一个 Jupyter Notebook 服务或者一个网站服务器），则需要把容器的端口“暴露”给主机的端口。\n操作任务： # 运行一个 Web 服务：在自定义的容器里运行一个简单的 Python Web 服务器。用电脑 B 上拉取下来的镜像启动容器： # -p \u0026lt;主机端口\u0026gt;:\u0026lt;容器端口\u0026gt; # 我们将主机的8888端口映射到容器的8000端口 docker run -it --rm -p 8888:8000 your-dockerhub-username/my-lab-env:1.0 在容器内启动服务：进入容器后，在 /app 目录下创建一个简单的网页文件： echo \u0026#34;\u0026lt;h1\u0026gt;Hello Docker!\u0026lt;/h1\u0026gt;\u0026#34; \u0026gt; index.html 然后启动 Python 内置的 HTTP 服务器，它默认在 8000 端口上运行：\npython3 -m http.server 8000 从主机浏览器访问：现在，打开电脑 B 上的任何浏览器（Chrome, Edge 等），访问 http://localhost:8888。 应该能看到 \u0026ldquo;Hello Docker!\u0026rdquo; 的字样。 成功地将容器内的网络服务暴露给了你的主机！ 第七步：整合所有操作 (最终工作流) # 在电脑 A 上（当环境有变化时候） # 更新环境：如果需要安装新的软件，就去修改 my-lab-env 文件夹里的 Dockerfile 重新构建：修改后，构建一个新的镜像，可以给它一个新的版本号，例如 1.1 docker build -t my-lab-image:1.1 . 打标签并推送：给新镜像打上Docker Hub标签并推送。 docker tag my-lab-image:1.1 your-dockerhub-username/my-lab-env:1.1 docker push your-dockerhub-username/my-lab-env:1.1 在电脑 B 上 # 拉取最新环境：定期从 Docker Hub 拉取你最新的环境镜像。 docker pull your-dockerhub-username/my-lab-env:1.1 准备项目文件夹：在电脑 B 上创建一个项目文件夹，例如 D:\\my-projects\\project-A 启动开发容器：使用 docker run 命令，挂载你的项目文件夹，并映射可能需要的端口。 # 示例: 挂载项目文件夹并映射8888端口 docker run -it --rm -v \u0026#34;D:\\my-projects\\project-A:/app\u0026#34; -p 8888:8000 your-dockerhub-username/my-lab-env:1.1 现在，你可以在这个容器里进行所有的开发、编译、运行等工作。电脑 B 上除了Docker之外，不需要安装任何其他的开发工具、库或依赖。代码和文件都安全地保存在 D:\\my-projects\\project-A 文件夹中\n","date":"25 October 2025","externalUrl":null,"permalink":"/posts/docker%E5%AE%8C%E6%95%B4%E6%8C%87%E5%8D%97/","section":"Posts","summary":"在这里写下您的文章摘要\u0026hellip;","title":"Docker完整指南","type":"posts"},{"content":"","date":"18 October 2025","externalUrl":null,"permalink":"/tags/algorithm/","section":"Tags","summary":"","title":"Algorithm","type":"tags"},{"content":"","date":"18 October 2025","externalUrl":null,"permalink":"/tags/c++/","section":"Tags","summary":"","title":"C++","type":"tags"},{"content":"","date":"18 October 2025","externalUrl":null,"permalink":"/tags/recursion/","section":"Tags","summary":"","title":"Recursion","type":"tags"},{"content":" 108. 将有序数组转换为二叉搜索树 # class Solution { public: TreeNode* sortedArrayToBST(vector\u0026lt;int\u0026gt;\u0026amp; nums) { return help(nums,0,nums.size()-1); } TreeNode* help(vector\u0026lt;int\u0026gt;\u0026amp; nums, int left, int right) { if (left \u0026gt; right) { //左右相同的下一步就是左边大于右边，左右相同得放进树里面 return nullptr; } int mid = (left + right + 1) / 2; TreeNode* root = new TreeNode(nums[mid]); root-\u0026gt;left = help(nums, left, mid - 1); root-\u0026gt;right = help(nums, mid + 1, right); return root; } }; 98. 验证二叉搜索树 # 方案 1：中序遍历（推荐的简洁方法）\n核心原理： 对一个二叉搜索树（BST）进行中序遍历（左 → 根 → 右），得到的节点值序列一定是严格递增的。\nclass Solution { private: // 必须用成员变量或引用参数来维护这个状态 long long prevVal = LLONG_MIN; public: bool isValidBST(TreeNode* root) { if (root == nullptr) { return true; } // 1. 递归检查左子树 if (!isValidBST(root-\u0026gt;left)) { return false; } // 2. 检查当前节点（中序遍历的核心逻辑） // 核心：当前值必须严格大于上一个值 if (root-\u0026gt;val \u0026lt;= prevVal) { return false; } // 3. 更新上一个值 prevVal = root-\u0026gt;val; // 4. 递归检查右子树 return isValidBST(root-\u0026gt;right); } }; 方案 2：上下限递归（更基础的方法）\nclass Solution { public: bool isValidBST(TreeNode* root) { return helper(root,LLONG_MIN,LLONG_MAX); } bool helper(TreeNode* root, long long lower, long long upper) { if (root == nullptr) return true; if (root-\u0026gt;val \u0026lt;= lower || root-\u0026gt;val \u0026gt;= upper) return false; bool left = helper(root-\u0026gt;left, lower, root-\u0026gt;val); bool right = helper(root-\u0026gt;right, root-\u0026gt;val, upper); return left \u0026amp;\u0026amp; right; } }; 230. 二叉搜索树中第 K 小的元素 # class Solution { public: int kthSmallest(TreeNode* root, int k) { vector\u0026lt;int\u0026gt; result; helper(root,result); return result[k-1]; } void helper(TreeNode* root, vector\u0026lt;int\u0026gt;\u0026amp; res) { if (root == nullptr) return; helper(root-\u0026gt;left,res); res.push_back(root-\u0026gt;val); helper(root-\u0026gt;right,res); } }; 使用布尔信号提前终止\nclass Solution { public: int kthSmallest(TreeNode* root, int k) { vector\u0026lt;int\u0026gt; result; helper(root, result, k); return result[k - 1]; } bool helper(TreeNode* root, vector\u0026lt;int\u0026gt;\u0026amp; res, int n) { // 递归终止条件 1: 节点为空，返回 false (继续遍历) if (root == nullptr) return false; // 递归终止条件 2: 已经找到 K 个元素，直接返回 true (停止) if (res.size() == n) { return true; } if (helper(root-\u0026gt;left, res, n)) return true; res.push_back(root-\u0026gt;val); if (res.size() == n) { return true; } return helper(root-\u0026gt;right, res, n); } }; 114. 二叉树展开为链表 # 方法一：普通方法（递归）\nclass Solution { public: void flatten(TreeNode* root) { vector\u0026lt;TreeNode*\u0026gt; res; help(root, res); int n = res.size(); for (int i = 0; i \u0026lt; n-1; i++) { TreeNode* node = res[i]; node-\u0026gt;left =nullptr; node-\u0026gt;right = res[i+1]; } } void help(TreeNode* root, vector\u0026lt;TreeNode*\u0026gt;\u0026amp; res) { if (root != nullptr) { res.push_back(root); help(root-\u0026gt;left, res); help(root-\u0026gt;right, res); } } }; 方法二：递归/逆向先序遍历 (Right → Left → Root)\nclass Solution { public: void flatten(TreeNode* root) { help(root); } TreeNode* pre = nullptr; void help(TreeNode* root) { if (root == nullptr) { return; } help(root-\u0026gt;right); help(root-\u0026gt;left); root-\u0026gt;right = pre; root-\u0026gt;left = nullptr; pre = root; return; } }; 方法三：迭代 + 寻找前驱 (Morris Traversal 思想) //看不懂思密达\nclass Solution { public: void flatten(TreeNode* root) { TreeNode* curr = root; while (curr != nullptr) { // 1. 如果有左子树 if (curr-\u0026gt;left != nullptr) { // 2. 找到左子树的最右节点 (前驱 predecessor) TreeNode* predecessor = curr-\u0026gt;left; while (predecessor-\u0026gt;right != nullptr) { predecessor = predecessor-\u0026gt;right; } // 3. 关键连接：将右子树接在左子树的末尾 predecessor-\u0026gt;right = curr-\u0026gt;right; // 4. 重排：将左子树整体搬到右侧 curr-\u0026gt;right = curr-\u0026gt;left; curr-\u0026gt;left = nullptr; // 清空左指针 } // 5. 前进到下一个节点（即原先的右子树或新的右子树的根） curr = curr-\u0026gt;right; } } }; ","date":"18 October 2025","externalUrl":null,"permalink":"/notes/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB/","section":"Notes","summary":"","title":"二叉树题目汇总","type":"notes"},{"content":"","date":"26 September 2025","externalUrl":null,"permalink":"/tags/git/","section":"Tags","summary":"","title":"Git","type":"tags"},{"content":"Learn Git Branching学习总结\n提交 # git commit git branch \u0026lt;name\u0026gt; //添加分支 git checkout \u0026lt;name\u0026gt; //切换到分支 git checkout -b bugFix //新建并且切换 合并分支 # 方法一：使用git merge合并两个分支 git checkout -b bugFix //新建并且切换 git commit git checkout main git commit //提交main git merge bugFix //将bugFix合并进main 方法二：使用git rebase合并两个分支 git checkout -b bugFix //新建并且切换 git commit git checkout main git commit git checkout bugFix git rebase main Head # 我们首先看一下 HEAD。 HEAD 是一个对当前所在分支的符号引用 —— 也就是指向你正在其基础上进行工作的提交记录。\nHEAD 总是指向当前分支上最近一次提交记录。大多数修改提交树的 Git 命令都是从改变 HEAD 的指向开始的。\nHEAD 通常情况下是指向分支名的（如 bugFix）。在你提交时，改变了 bugFix 的状态，这一变化通过 HEAD 变得可见。\n如果想看 HEAD 指向，可以通过 cat .git/HEAD 查看， 如果 HEAD 指向的是一个引用，还可以用 git symbolic-ref HEAD 查看它的指向\n相对引用 ^ # 使用^向上移动 1 个提交记录;使用~\u0026lt;num\u0026gt; 向上移动多个提交记录，如 ~3\n让分支指向另一个提交 例如 :\ngit checkout main^ git branch -f main HEAD~3 git branch -f three C2 //让three指向C2 会将 main 分支强制指向 HEAD 的第 3 级 parent 提交。\n撤销变更 # git reset HEAD~1 //当前分支撤销到上一级，仅在本地 git revert C1 //当前分支添加一个新的分支，里面的操作可为撤销，可以远程 git revert C1 //撤销到 C1 整理提交记录 # git cherry-pick \u0026lt;提交号\u0026gt;... git cherry-pick C2 C4` 将 C2 C4（分支上的 指的是哈希值）复制到 main（当前分支）分支 git cherry-pick xx ` 可以将提交树上任何地方的提交记录取过来追加到 HEAD 上 交互式的 rebase git rebase -i HEAD~4//对 HEAD~4 之后的提交修改顺序 创建标签 # git tag v1 C1 git tag v1 main~2(main 的上两级) //建立一个标签，指向提交记录 C1，表示这是我们 1.0 版本 git describe \\\u0026lt;ref\u0026gt;\n\u0026lt;ref\u0026gt; 可以是任何能被 Git 识别成提交记录的引用，如果你没有指定的话，Git 会使用你目前所在的位置（HEAD）。\n它输出的结果是这样的：\u0026lt;tag\u0026gt;_\u0026lt;numCommits\u0026gt;_g\u0026lt;hash\u0026gt;\ntag 表示的是离 ref 最近的标签， numCommits 是表示这个ref与tag相差有多少个提交记录， hash 表示的是你所给定的 ref 所表示的提交记录哈希值的前几位。\n当 ref 提交记录上有某个标签时，则只输出标签名称\n两个 parent 节点 # 若有两个 parnet 节点，HEAD^ 代表第一个 parnet 节点，HEAD^2 代表另一个不近的节点。\ngit checkout HEAD^2 //去到当前分支的较远的 parent 节点 git branch bugWork main^^2^ //创建 bugWork 并且移动到 main 父节点的第二个父节点的父节点 偏离的提交历史 # 假设你周一克隆了一个仓库，然后开始研发某个新功能。到周五时，你新功能开发测试完毕，可以发布了。但是 —— 天啊！你的同事这周写了一堆代码，还改了许多你的功能中使用的 API，这些变动会导致你新开发的功能变得不可用。但是他们已经将那些提交推送到远程仓库了，因此你的工作就变成了基于项目旧版的代码，与远程仓库最新的代码不匹配了。\ngit fetch; //更新了本地仓库中的远程分支 git rebase o/main; //将我们的工作移动到最新的提交记录下 git push //推送到远程仓库 也可以使用 merge\ngit fetch; //更新了本地仓库中的远程分支 git merge o/main; //将合并了新变更到我们的本地分支（为了包含远程仓库的变更 git push //推送到远程仓库 git pull 就是 fetch 和 merge 的简写，类似的 git pull --rebase 就是 fetch 和 rebase 的简写\n远程服务器拒绝!(Remote Rejected) # 远程服务器拒绝直接推送(push)提交到 main, 因为策略配置要求 pull requests 来提交更新.\n你应该按照流程,新建一个分支, 推送(push)这个分支并申请 pull request,但是你忘记并直接提交给了 main.现在你卡住并且无法推送你的更新\n新建一个分支 feature, 推送到远程服务器. 然后 reset 你的 main 分支和远程服务器保持一致, 否则下次你 pull 并且他人的提交和你冲突的时候就会有问题.\ngit branch -f main o/main git checkout -b feature C2 git push origin feature 合并多个分支 # git fetch git rebase o/main side1 git rebase side1 side2 git rebase side2 side3 git push ","date":"26 September 2025","externalUrl":null,"permalink":"/posts/git%E5%AD%A6%E4%B9%A0/","section":"Posts","summary":"Learn Git Branching学习总结","title":"Git学习","type":"posts"},{"content":"B 站“灵茶山艾府“的解释\n递归的核心思想：不是人肉压栈，而是“甩锅” # 初学者的困境：人肉模拟调用栈\n当递归层数很少时，比如三层，你还能模拟：main 调用 A，A 调用 B，B 调用 C。C 返回给 B，B 返回给 A，A 返回给 main。但当层数一多，你的大脑就会像计算机内存溢出一样，难以追踪。\n正确的递归思维方式是“信任”或者叫“信念之跃”（Leap of Faith）。\n你只需要关注两件事：\n1.终止条件（Base Case）：什么时候问题小到可以直接解决，不需要再“甩锅”给下一层了？\n2.递归关系（Recursive Relation）：如何把当前问题，分解成一个或多个规模更小的同类子问题，并假设（信任）下一层调用能完美解决这些子问题。然后，你只需要思考如何利用子问题的解来组合成当前问题的解。\n**你不需要去想下一层是怎么实现的，你只要相信它能给你正确的结果就行了。**就像调用一个库函数sort()，你不会去关心它内部是快排还是归并.\n把递归函数本身，也当成一个黑盒的、可信赖的库函数来调用。\n以二叉树为例 # #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; // 定义二叉树节点 struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} }; /* 我们来定义函数 maxDepth(root) 它的功能是：接收一个树的根节点，返回这棵树的最大深度。 */ int maxDepth(TreeNode* root) { // 1. 终止条件 (Base Case) // 如果这个节点是空的（比如一个叶子节点的子节点）， // 那么它构成的树深度就是 0。这是最简单、可以直接回答的问题。 if (root == nullptr) { return 0; } // 2. 递归关系 (Recursive Relation) // 对于任何一个非空的节点 root，它的最大深度是多少？ // 我们可以把它分解成两个子问题： // - 左子树的最大深度是多少？ // - 右子树的最大深度是多少？ // 这两个子问题的规模都比当前问题（整棵树的深度）要小。 // 而且它们是同类问题：都是“计算一棵树的最大深度”。 // 所以，我们可以“甩锅”了！ // 我假设 maxDepth() 这个函数已经能完美工作了（信念之跃）。 // 我把它当成一个已知的、可靠的工具来调用。 // 我“相信”下面这行代码能正确计算出左子树的深度。 // 我不去想 aleftDepth 是怎么一步步算出来的。 int leftDepth = maxDepth(root-\u0026gt;left); // 我同样“相信”这行代码能正确计算出右子树的深度。 int rightDepth = maxDepth(root-\u0026gt;right); // 3. 组合子问题的解 // 现在，我已经拿到了两个子问题的答案：leftDepth 和 rightDepth。 // 如何用这两个答案来解决我当前的问题（以 root 为根的树的深度）？ // 很显然，整棵树的深度 = 左右子树深度的较大者 + 1 (当前这一层) return std::max(leftDepth, rightDepth) + 1; } int main() { /* 构造一棵树: 3 / \\ 9 20 / \\ 15 7 */ TreeNode* root = new TreeNode(3); root-\u0026gt;left = new TreeNode(9); root-\u0026gt;right = new TreeNode(20); root-\u0026gt;right-\u0026gt;left = new TreeNode(15); root-\u0026gt;right-\u0026gt;right = new TreeNode(7); std::cout \u0026lt;\u0026lt; \u0026#34;这棵树的最大深度是: \u0026#34; \u0026lt;\u0026lt; maxDepth(root) \u0026lt;\u0026lt; std::endl; // 应该输出 3 delete root-\u0026gt;left; delete root-\u0026gt;right-\u0026gt;left; delete root-\u0026gt;right-\u0026gt;right; delete root-\u0026gt;right; delete root; return 0; } 如何正确思考 maxDepth(root) 的过程？\n1.我的目标：实现 maxDepth(root) 函数。\n2.第一步：找终止条件。 什么情况下最简单？树是空的！if (root == nullptr)，深度就是 0。搞定。\n3.第二步：找递归关系。 如果树不空，root 指向一个节点。这棵树的深度和它的左右孩子有什么关系？\n左子树的深度。\n右子树的深度。\n整棵树的深度就是 max(左深度, 右深度) + 1。\n4.第三步：写代码（信念之跃）。 如何获取左子树的深度？直接调用maxDepth(root-\u0026gt;left)。相信它！ 不要去想它内部是怎么对 root-\u0026gt;left 的子节点进行递归的。就把它当成 int leftDepth = getLeftDepth() 这么一个普通的函数调用。\n如何获取右子树的深度？同理，调用 maxDepth(root-\u0026gt;right)。相信它！\n拿到 leftDepth 和 rightDepth 后，根据第二步的分析，return std::max(leftDepth, rightDepth) + 1;。\n整个思考过程，我们只关注“当前层”的逻辑。 我们把对子树的处理完全委托给了递归调用，我们是“管理者”，不是“微观执行者”。\n再举一例：二叉树的前序遍历 # 前序遍历的顺序是：根 -\u0026gt; 左 -\u0026gt; 右。这个定义本身就充满了递归的味道\nvoid preOrderTraversal(TreeNode* root) { // 1. 终止条件 if (root == nullptr) { return; // 空树就直接返回，什么也不做 } // 2. 处理当前节点 (根) std::cout \u0026lt;\u0026lt; root-\u0026gt;val \u0026lt;\u0026lt; \u0026#34; \u0026#34;; // 访问根节点 // 3. 递归处理左子树 (左) // “信念之跃”：我相信这个调用会完美地以前序遍历的方式打印完整个左子树 preOrderTraversal(root-\u0026gt;left); // 4. 递归处理右子树 (右) // “信念之跃”：我相信这个调用会完美地以前序遍历的方式打印完整个右子树 preOrderTraversal(root-\u0026gt;right); } 正确思考 preOrderTraversal：\n1.我的目标：按“根-左-右”的顺序打印树。\n2.终止条件：root 是 nullptr，没什么可打印的，直接 return。\n3.当前层的逻辑：如果 root 不是 nullptr，根据“根-左-右”的定义，我应该：\n先处理“根”：cout \u0026lt;\u0026lt; root-\u0026gt;val;\n然后处理“左”：怎么处理？这是一个规模更小的同类问题，直接调用 preOrderTraversal(root-\u0026gt;left); 来搞定整个左子树。相信它能行！\n最后处理“右”：同理，调用 preOrderTraversal(root-\u0026gt;right); 来搞定整个右子树。相信它也能行！\n代码和逻辑完全一一对应，清晰明了。 你根本不需要去想，调用 preOrderTraversal(root-\u0026gt;left)之后，它又会怎么打印，怎么调用它的左孩子和右孩子。你只要相信这个函数的功能定义是正确的，你调用它，它就能完成任务。\n总结与建议 # 明确函数定义：在写递归函数之前，用一句话清晰地描述这个函数的功能。例如：“maxDepth(node)的功能是返回以 node 为根的子树的最大深度”。在后续的递归调用中，始终坚信你调用的就是这个已经实现的功能。\n只考虑当前层：你的所有逻辑都应该只围绕“当前节点”展开。你需要做什么？你需要从子问题的解中得到什么信息？你如何利用这些信息？\n找到终止条件：思考什么情况下问题规模最小，可以被直接解决，不再需要递归。这是递归的出口，没有它就会无限循环，导致“栈溢出”。\n信任递归调用：这是最关键的一步。当你对 function(sub_problem) 进行调用时，就把它当成一个已知的、正确的黑盒。你的任务不是去追踪它的执行，而是去使用它的返回结果。\n当你下次再遇到一个递归问题时，请抑制住你的大脑去模拟整个调用栈的冲动。强迫自己用上面的思维模式去思考，多练习几次，你会发现递归问题会变得异常清晰和简单。它是一种将复杂问题分解为简单、重复单元的强大思维工具。\n1. 基础遍历类 # 这类问题的核心是“访问”到每一个节点并执行简单操作，递归函数本身通常没有返回值（void）或者返回一个包含所有节点值的列表。\n核心思路： 定义一个 traverse(node) 函数，在函数内部先处理当前节点，然后递归调用 traverse(node-\u0026gt;left) 和 traverse(node-\u0026gt;right)。根据处理当前节点的时机不同，分为前、中、后序遍历。\n经典题目:\n144. 二叉树的前序遍历 # class Solution { public: void perorder(TreeNode* root, vector\u0026lt;int\u0026gt;\u0026amp; res) { if (root == nullptr) return; res.push_back(root-\u0026gt;val); perorder(root-\u0026gt;left, res); perorder(root-\u0026gt;right, res); } vector\u0026lt;int\u0026gt; preorderTraversal(TreeNode* root) { vector\u0026lt;int\u0026gt; res; perorder(root, res); return res; } }; 94. 二叉树的中序遍历 # class Solution { public: void inorder(TreeNode *node, vector\u0026lt;int\u0026gt; \u0026amp;res) { if (node == nullptr) return; inorder(node-\u0026gt;left, res); res.push_back(node-\u0026gt;val); inorder(node-\u0026gt;right, res); } vector\u0026lt;int\u0026gt; inorderTraversal(TreeNode *root) { vector\u0026lt;int\u0026gt; res; inorder(root, res); return res; } }; 145. 二叉树的后序遍历 # class Solution { public: void postorder(TreeNode* root, vector\u0026lt;int\u0026gt;\u0026amp; res) { if (root == nullptr) return; postorder(root-\u0026gt;left, res); postorder(root-\u0026gt;right, res); res.push_back(root-\u0026gt;val); } vector\u0026lt;int\u0026gt; postorderTraversal(TreeNode* root) { vector\u0026lt;int\u0026gt; res; postorder(root, res); return res; } }; 2. 分治 / 自下而上信息汇总 # 这是最最常见的一类递归问题。你相信递归函数能帮你解决子问题，然后你只需要思考如何利用子问题的解来解决当前问题。\n核心思路 ： “我不知道怎么解决整棵树的问题，但我假设 solve(root-\u0026gt;left) 和 solve(root-\u0026gt;right) 已经帮我解决了左右子树的问题并返回了正确的结果。现在，我只需要在当前 root 节点，利用这两个结果，计算出当前树的结果，然后 return 回去。”\n经典题目:\n104. 二叉树的最大深度 # 我们之前讨论过的\n左子树深度 = solve(root-\u0026gt;left), 右子树深度 = solve(root-\u0026gt;right)\n当前树深度 = max(左子树深度, 右子树深度) + 1\n111. 二叉树的最小深度 # 最大深度的变体，注意处理只有单边子树的情况\nint minDepth(TreeNode* root) { if (root == nullptr) return 0; int ldepth = minDepth(root-\u0026gt;left); int rdepth = minDepth(root-\u0026gt;right); if (root-\u0026gt;right == nullptr) { return ldepth+1; } if (root-\u0026gt;left == nullptr) { return rdepth+1; } return min(ldepth, rdepth) + 1; } 543. 二叉树的直径 # 子问题返回子树的深度。\n当前节点计算的“穿过我的直径”是 左深度 + 右深度，同时更新全局最大值。\nint landrDepth(TreeNode* root,int\u0026amp; maxdepth) { if (root == nullptr) return 0; int ldepth = landrDepth(root-\u0026gt;left,maxdepth); int rdepth = landrDepth(root-\u0026gt;right,maxdepth); int currentdepth = ldepth + rdepth; maxdepth = max(maxdepth,currentdepth); return max(ldepth,rdepth)+1; } int diameterOfBinaryTree(TreeNode* root) { int maxdepth=0; landrDepth(root,maxdepth); return maxdepth; } 124. 二叉树中的最大路径和 # (其他路径问题在第三部分) 辅助函数的主要功能是求解单边最大，这样计算左右两边最大就可以得到想要的最大值。 不要拘泥于辅助函数必须返回目标值，这种直接得到目标值行不通的，可以考虑分解目标，但是将目标值存储在变量中。\nint globalmax = numeric_limits\u0026lt;int\u0026gt;::min(); int cacule2(TreeNode \\*root) { if (root == nullptr) return 0; int lmax = max(0,cacule2(root-\u0026gt;left)); int rmax = max(0,cacule2(root-\u0026gt;right)); int currentnum = root-\u0026gt;val + lmax + rmax; globalmax = max(currentnum, globalmax); return root-\u0026gt;val+max(lmax,rmax); } int maxPathSum(TreeNode \\*root) { globalmax = numeric_limits\u0026lt;int\u0026gt;::min(); cacule2(root); return globalmax; } 110. 平衡二叉树 # 引入-1，蛮有意思\u0026hellip;\u0026hellip;\n子问题需要返回两个信息：子树是否平衡，以及子树的高度。\nclass Solution { public: bool isBalanced(TreeNode* root) { return dep(root)!=-1; } int dep(TreeNode* root) { if(root==nullptr){ return 0; } int ldepth = dep(root-\u0026gt;left); if(ldepth==-1){ return -1; } int rdepth = dep(root-\u0026gt;right); if(rdepth==-1){ return -1; } // chazhi = max(chazhi,abs(ldepth - rdepth)); if(abs(ldepth - rdepth)\u0026gt;1){ return -1; } return max(ldepth,rdepth)+1; } }; 236.二叉树的最近公共祖先 # 子问题返回在子树中是否找到了 p 或 q。\n当前节点根据左右子树的返回情况做出判断。\n把一个复杂的“寻找 LCA”问题，降维成了一个简单的“寻找 p 或 q”的问题 emmm 怪有意思\u0026hellip;\u0026hellip;\nTreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { //如果你确定树中所有节点的值唯一（比如二叉搜索树 BST 中常常是这样），那用 root-\u0026gt;val == p-\u0026gt;val 也可以。 if (root == nullptr || root == p || root == q) { return root; } // 函数不是在“寻找祖先”，而是在“汇报发现”。这个算法巧妙地改变了子问题的定义 // 把一个复杂的“寻找LCA”问题，降维成了一个简单的“寻找p或q”的问题 TreeNode *lAncestor = lowestCommonAncestor(root-\u0026gt;left, p, q); TreeNode *rAncestor = lowestCommonAncestor(root-\u0026gt;right, p, q); if (lAncestor ==nullptr\u0026amp;\u0026amp;rAncestor==nullptr) return nullptr; if (lAncestor != nullptr \u0026amp;\u0026amp; rAncestor != nullptr) return root; if (lAncestor == nullptr \u0026amp;\u0026amp; rAncestor != nullptr) return rAncestor; return lAncestor; } 3. 路径问题 / 自上而下信息传递 # 这类问题与上一类相反，子问题的解决需要依赖其父节点的信息。因此，你需要通过递归函数的参数将信息自上而下地传递下去。\n核心思路： “我需要定义一个 solve(node, state) 函数，其中 state 是从根节点到我父节点为止积累的状态。在函数内部，我根据 state 和当前node 的值计算出新的状态 new_state，然后把它传递给我的子节点solve(node-\u0026gt;left, new_state)和 solve(node-\u0026gt;right, new_state)。”\n经典题目:\n112. 路径总和 # 向下传递 targetSum - node-\u0026gt;val。\n注意代码中的targetSum是值传递，也就是说并不影响函数内部操作中对其值的修改，同一层执行完res1再res2,里面传入的targetSum是相同的。\nbool hasPathSum(TreeNode *root, int targetSum) { if (root == nullptr) return 0; targetSum -= root-\u0026gt;val; if (root-\u0026gt;left == nullptr \u0026amp;\u0026amp; root-\u0026gt;right == nullptr) return targetSum == 0; bool res1 = hasPathSum(root-\u0026gt;left, targetSum); bool res2 = hasPathSum(root-\u0026gt;right, targetSum); return res1 || res2; } 129. 求根节点到叶节点数字之和 # 向下传递 currentSum * 10 + node-\u0026gt;val。\n辅助函数并没有返回值，而是把值存在了常量里面。因为返回的不是结果，所以不用只是子问题的答案，可以是最终结果 totalsum。\nclass Solution { public: int totalsum = 0; void traverse(TreeNode* node, int currentnum) { if (node == nullptr) return; int parentnum = currentnum * 10 + node-\u0026gt;val; if (node-\u0026gt;left == nullptr \u0026amp;\u0026amp; node-\u0026gt;right == nullptr) { totalsum = totalsum + parentnum; return; } traverse(node-\u0026gt;left, parentnum); traverse(node-\u0026gt;right, parentnum); } int sumNumbers(TreeNode* root) { traverse(root, 0); return totalsum; } }; 257. 二叉树的所有路径 # 向下传递当前路径的字符串 currentPath + \u0026quot;-\u0026gt;\u0026quot; + node-\u0026gt;val。\nclass Solution { public: vector\u0026lt;string\u0026gt; ans; void getpath(TreeNode* root, string path) { if (root == nullptr) { return; } path = path+to_string(root-\u0026gt;val); if (root-\u0026gt;right == nullptr \u0026amp;\u0026amp; root-\u0026gt;left == nullptr) { ans.push_back(path); return; } path = path+\u0026#34;-\u0026gt;\u0026#34;; getpath(root-\u0026gt;right, path); getpath(root-\u0026gt;left, path); } vector\u0026lt;string\u0026gt; binaryTreePaths(TreeNode* root) { getpath(root, \u0026#34;\u0026#34;); return ans; } }; 优化方案：使用回溯（Backtracking）避免浪费 还不太会，放放吧⏳\n路径用 string\u0026amp; path 传引用，递归中添加/移除（pop_back），结果直接 push 到共享 res\n无临时向量创建/合并; 字符串修改就地（O(1) 添加/移除）; 空间：O(log n) 递归栈 + O(n _ L) 最终 res; 时间：O(n _ L) 但常数小，无拷贝。 class Solution { public: void getpath(TreeNode* node, string\u0026amp; path, vector\u0026lt;string\u0026gt;\u0026amp; res) { if (node == nullptr) return; // 添加当前值（记录长度以便回溯） int prev_len = path.size(); path += to_string(node-\u0026gt;val); if (node-\u0026gt;left == nullptr \u0026amp;\u0026amp; node-\u0026gt;right == nullptr) { res.push_back(path); // 直接 push 当前路径 } else { path += \u0026#34;-\u0026gt;\u0026#34;; // 添加箭头 getpath(node-\u0026gt;left, path, res); getpath(node-\u0026gt;right, path, res); path.resize(path.size() - 2); // 移除 \u0026#34;-\u0026gt;\u0026#34; } path.resize(prev_len); // 移除当前值（回溯） } vector\u0026lt;string\u0026gt; binaryTreePaths(TreeNode* root) { vector\u0026lt;string\u0026gt; res; string path = \u0026#34;\u0026#34;; getpath(root, path, res); return res; } }; 113. 路径总和 II # 路径总和的升级版 向下传递当前路径的节点列表 vector\u0026lt;int\u0026gt; currentPath。\nclass Solution { public: vector\u0026lt;int\u0026gt; path; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; ans; void cacula(TreeNode* root, int currentnum) { if(root==nullptr){ return; } path.push_back(root-\u0026gt;val); currentnum = currentnum - root-\u0026gt;val; if (root-\u0026gt;right == nullptr \u0026amp;\u0026amp; root-\u0026gt;left == nullptr) { if (currentnum == 0) { ans.push_back(path); path.pop_back(); return; } path.pop_back(); return; } cacula(root-\u0026gt;left, currentnum); cacula(root-\u0026gt;right, currentnum); path.pop_back(); } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; pathSum(TreeNode* root, int targetSum) { if(root==nullptr) { return ans; } cacula(root, targetSum); return ans; } }; 4. 结构比较与修改 # 这类问题通常涉及两棵树，或者需要翻转、修改树的结构。\n核心思路：\n递归函数通常同时作用于两棵树的对应节点，或者在修改完当前节点的结构后，再对子节点进行递归调用。\n经典题目:\n100. 相同的树 # isSameTree(p, q) 依赖于 isSameTree(p-\u0026gt;left, q-\u0026gt;left) 和 isSameTree(p-\u0026gt;right, q-\u0026gt;right) 的结果。\nclass Solution { public: bool isSameTree(TreeNode* p, TreeNode* q) { if(p==nullptr\u0026amp;\u0026amp;q==nullptr){ return true; } if((p==nullptr\u0026amp;\u0026amp;q!=nullptr)||(p!=nullptr\u0026amp;\u0026amp;q==nullptr)||p-\u0026gt;val!=q-\u0026gt;val) { return false; } bool isLeftSame = isSameTree(p-\u0026gt;left,q-\u0026gt;left); bool isRightSame = isSameTree(p-\u0026gt;right,q-\u0026gt;right); return isLeftSame\u0026amp;\u0026amp;isRightSame; } }; 101. 对称二叉树 # 这是判断两棵树是否镜像对称的变体。递归函数 isMirror(p, q) 依赖于 isMirror(p-\u0026gt;left, q-\u0026gt;right) 和 isMirror(p-\u0026gt;right, q-\u0026gt;left)。\nbool isMirror(TreeNode* p, TreeNode* q) { if (p == nullptr \u0026amp;\u0026amp; q == nullptr) { return true; } if ((p == nullptr \u0026amp;\u0026amp; q != nullptr) || (p != nullptr \u0026amp;\u0026amp; q == nullptr) || (p-\u0026gt;val != q-\u0026gt;val)) { return false; } bool isSameOuter = isMirror(p-\u0026gt;left, q-\u0026gt;right); bool isSameInner = isMirror(p-\u0026gt;right, q-\u0026gt;left); return isSameOuter \u0026amp;\u0026amp; isSameInner; } bool isSymmetric(TreeNode* root) { if (root == nullptr) { return true; } return isMirror(root-\u0026gt;left, root-\u0026gt;right ); } 226. 翻转二叉树 # 在当前节点交换左右子节点，然后递归调用 invertTree(root-\u0026gt;left) 和 invertTree(root-\u0026gt;right)。\nclass Solution { public: TreeNode* invertTree(TreeNode* root) { if (root == nullptr) return nullptr; TreeNode* left = invertTree(root-\u0026gt;left); TreeNode* right = invertTree(root-\u0026gt;right); root-\u0026gt;right = left; root-\u0026gt;left = right; return root; } }; 总结与练习建议 # 题号 题目 核心思路 类 别 状态 94, 144, 145 二叉树遍历 访问所有节点 基础遍历 ✅ 104, 111 树的深度 从子树获取深度，组合成当前深度 分治 / 自下而上 ✅ 543 二叉树的直径 从子树获取深度，计算穿过当前节点的直径 分治 / 自下而上 ✅ 110 平衡二叉树 从子树获取“是否平衡”和“深度”两个信息 分治 / 自下而上 ✅ 236 最近公共祖先 从子树获取是否包含目标节点的信息 分治 / 自下而上 ✅ 112, 113 路径总和 将目标和减去当前值，向下传递 路径 / 自上而下 ✅ 129 求根到叶节点数字之和 将当前路径和乘以 10 加上当前值，向下传递 路径 / 自上而下 ✅ 257 二叉树的所有路径 将当前路径字符串拼接上当前值，向下传递 路径 / 自上而下 ✅ 100 相同的树 同时递归比较两棵树的对应子树 结构比较 ✅ 101 对称二叉树 同时递归比较一棵树的内外侧子树 结构比较 ✅ 226 翻转二叉树 交换当前节点的左右子节点，然后递归翻转子树 结构修改 ✅ 如何练习：\n从基础遍历开始，确保你理解前、中、后序的区别。\n主攻“分治 / 自下而上”，这是最重要的递归模式。以“最大深度”为模板，彻底理解“信任”递归调用的思想。\n然后练习“路径 / 自上而下”，理解通过参数传递状态的方法。\n最后解决结构类问题，它们通常是前面几种思想的结合或变体。\n几乎所有二叉树问题都能被归入这几类。当你遇到一个新问题时，先思考一下：“解决这个问题，我需要从子树获得什么信息，还是需要向子树传递什么信息？” 这能帮助你快速确定递归的结构。\n一些问题 # 是否需要返回值问题: # 如果叶节点或中间节点需要“向上报告”信息（如子树结果），用返回值 如果只是“遍历 + 收集到外部容器”，用 void + 共享状态\n更多练习题目见二叉树题目汇总\n","date":"15 September 2025","externalUrl":null,"permalink":"/notes/recursive_relation/","section":"Notes","summary":"","title":"递归基础及题目（Recursive Relation）","type":"notes"},{"content":"","date":"8 September 2025","externalUrl":null,"permalink":"/tags/conda/","section":"Tags","summary":"","title":"Conda","type":"tags"},{"content":"https://docs.conda.io/projects/conda/en/latest/user-guide/getting-started.html\n创建环境 # 创建一个新环境\nconda create -n \u0026lt;env-name\u0026gt; 创建环境并且下载指定包\nconda create -n myenvironment python numpy pandas conda create -n myenv scipy=0.17.3 //特定库版本 创建环境指定特定pyhton版本 conda create -n myenv python=3.9 conda create -n myenv python=3.9 特定pyhton版本和多个库 conda create -n myenv python=3.9 scipy=0.17.3 astroid babel\n查看所有环境 # conda info --envs 例如： conda environments: base /home/username/Anaconda3 myenvironment * /home/username/Anaconda3/envs/myenvironment 当前环境带*\n改变当前环境为默认的一个\nconda activate 下载库 # # via environment activation conda activate myenvironment conda install matplotlib # via command line option conda install --name myenvironment matplotlib If a package you want is located in another channel, such as conda-forge, you can manually specify the channel when installing the package:\nconda install conda-forge::numpy 更新Conda # 查看Conda版本\nconda --version 更新到最新版本\nconda update conda ","date":"8 September 2025","externalUrl":null,"permalink":"/posts/conda_start/","section":"Posts","summary":"Conda使用","title":"Conda Start","type":"posts"},{"content":" 莫里斯遍历 - 实例走查 # 我们将使用下面的树来进行中序遍历。遍历的结果应该是 [1, 2, 3, 4, 6]。\n初始状态:\ncurrent 指向根节点 4。 result (结果数组) 为 []。 4 \u0026lt;\u0026ndash; current / \\ 2 6 /\\ 1 3\n第 1 步 # current = 4\n判断: current (4) 有左孩子 2。\n动作:\n找到 current (4) 的左子树 (2 为根) 的最右节点。这个节点是 3。 3 的右指针是 nullptr。 建立线索: 将 3 的右指针指向 current (4)。 current 向左移动：current = current-\u0026gt;left (移向 2)。 树的状态: 4 / \\ 2 6 / 1 3 \u0026ndash;+ ^ | |___| (线索指向 4)\nresult: []\n第 2 步 # current = 2\n判断: current (2) 有左孩子 1。\n动作:\n找到 current (2) 的左子树 (1 为根) 的最右节点。这个节点就是 1 本身。 1 的右指针是 nullptr。 建立线索: 将 1 的右指针指向 current (2)。 current 向左移动：current = current-\u0026gt;left (移向 1)。 树的状态: 4 / 2 6 /\n1 3 \u0026ndash;+ ^ \\ | | +\u0026mdash;-|\u0026ndash;(线索指向 2) |_______| (线索指向 4)\nresult: [] 第 3 步 # current = 1\n判断: current (1) 没有左孩子。\n动作:\n访问 1。 current 向右移动：current = current-\u0026gt;right (根据我们建立的线索，它会移向 2)。 result: [1]\n第 4 步 # current = 2\n判断: current (2) 有左孩子 1。\n动作:\n再次找到 current (2) 的左子树的最右节点，还是 1。 这一次，我们发现 1 的右指针指向 current (2)，说明我们已经处理完 current 的左子树了。 访问 2。 断开线索: 将 1 的右指针恢复为 nullptr。 current 向右移动：current = current-\u0026gt;right (移向 3)。 树的状态 (1-\u0026gt;2 的线索已断开): 4 / \\ 2 6 / 1 3 \u0026ndash;+ ^ | |___| (线索指向 4)\nresult: [1, 2]\n第 5 步 # current = 3\n判断: current (3) 没有左孩子。\n动作:\n访问 3。 current 向右移动：current = current-\u0026gt;right (根据我们建立的线索，它会移向 4)。 result: [1, 2, 3]\n第 6 步 # current = 4\n判断: current (4) 有左孩子 2。\n动作:\n再次找到 current (4) 的左子树的最右节点，还是 3。 我们发现 3 的右指针指向 current (4)，说明我们已经处理完 current 的左子树了。 访问 4。 断开线索: 将 3 的右指针恢复为 nullptr。 current 向右移动：current = current-\u0026gt;right (移向 6)。 树的状态 (完全恢复): 4 / \\ 2 6 / 1 3\nresult: [1, 2, 3, 4]\n第 7 步 # current = 6\n判断: current (6) 没有左孩子。\n动作:\n访问 6。 current 向右移动：current = current-\u0026gt;right (移向 nullptr)。 result: [1, 2, 3, 4, 6]\n结束 # current = nullptr 判断: 循环结束。 最终，我们得到了正确的中序遍历结果 [1, 2, 3, 4, 6]，并且树的结构也完全恢复到了初始状态。\n希望这个一步步的分解能帮助你理解莫里斯遍历的工作流程！\n","date":"3 September 2025","externalUrl":null,"permalink":"/notes/morris_traversal/","section":"Notes","summary":"","title":"Morris Traversal","type":"notes"},{"content":"步骤 1: 在 GitHub 上创建新的远程仓库 步骤 2: 在本地电脑上操作\n# 打开 Git Bash进入你的项目文件夹 cd ~/Desktop/my-first-project # 初始化 Git 仓库: git init #添加所有文件到暂存区: git add . # 提交文件到本地仓库: git commit -m \u0026#34;Initial commit\u0026#34; #重命名主分支为 main git branch -m main # 关联本地仓库和远程仓库: git remote add origin https://github.com/YourUsername/YourProjectName.git # 把下面的 URL 换成你自己的仓库 URL # 推送代码到 GitHub: git push -u origin main ","date":"2 September 2025","externalUrl":null,"permalink":"/posts/a_folder_to_git/","section":"Posts","summary":"本地文件夹上传至GitHub","title":"A Folder to Git","type":"posts"},{"content":"创建项目文件夹\n打开命令行工具（比如 CMD、PowerShell 或者 Windows Terminal），然后进入存放所有代码的目录（例如 D:\\projects）。\n# 1. 进入项目的父目录(请根据实际情况修改 \u0026#34;D:\\projects\u0026#34;) cd D:\\projects 2. 创建新文件夹作为根目录 mkdir my_new_project 3. 进入这个新创建的文件夹 cd my_new_project 创建虚拟环境\n# 确保在项目根目录下 (D:\\projects\\my_new_project) # -m venv 的意思是 \u0026#34;以模块(module)方式运行 venv\u0026#34; # 最后的 \u0026#34;venv\u0026#34; 是给虚拟环境文件夹取的名字 python -m venv venv # 执行完毕后，会发现项目文件夹里多出了一个名为 venv 的子文件夹。这里面包含了独立的 Python 解释器和未来将要安装的库。 激活虚拟环境\n# 在 Windows PowerShell 中，运行以下命令 .\\venv\\Scripts\\activate 激活成功后，会看到命令行提示符的前面多了一个 (venv) 的标记，像这样： (venv) PS D:\\projects\\my_new_project\u0026gt; 这个 (venv) 标志非常重要，它告诉你当前终端已经处于激活的虚拟环境中。所有后续的 pip 安装和 python 命令都将只在这个环境内生效。\n# 在 VS Code 中打开项目,确保还在项目根目录下 (有 (venv) 标志),这个命令会用 VS Code 打开当前文件夹 code . 配置 VS Code 解释器\n1.当用 VS Code 打开带有 venv 文件夹的项目时，VS Code 通常会在右下角弹出一个提示：We noticed a new environment has been created. Do you want to select it for the workspace folder? (我们发现了一个新环境，您要为工作区选择它吗？)。\n请务必点击 Yes。\n2.如果 VS Code 没有自动提示，可以手动选择：\n按下 Ctrl+Shift+P 打开命令面板。\n输入并选择 Python: Select Interpreter (Python: 选择解释器)。\n在列表中，选择那个带有 (\u0026lsquo;venv\u0026rsquo;: venv) 标志或者路径中包含 .\\venv\\Scripts\\python.exe 的选项。\n安装项目所需的库\n现在，可以在 VS Code 的集成终端中（确保终端前面有 (venv) 标志）安装任何需要的第三方库了。\n完整的、专业的开发流程\n在项目开始时就创建.gitignore 文件，并加入 venv/\n在虚拟环境中安装项目所需的库（例如pip install pandas）\n每当安装或更新了重要的库之后，就更新 requirements.txt文件： pip freeze \u0026gt; requirements.txt\n将源代码、.gitignore 和更新后的 requirements.txt 一起提交到GitHub。\ngit add . git commit -m \u0026#34;Add new feature and update dependencies\u0026#34; git push 拿到项目后,只需要执行以下几步\n克隆仓库 git clone \u0026lt;your_repo_url\u0026gt; cd \u0026lt;your_repo_name\u0026gt; 创建并激活他们自己的venv python -m venv venv 在Windows上: .\\venv\\Scripts\\activate 在macOS/Linux上: source venv/bin/activate 根据依赖列表，一键安装所有库 pip install -r requirements.txt ","date":"11 August 2025","externalUrl":null,"permalink":"/posts/create_new_project/","section":"Posts","summary":"带虚拟环境的 Python 项目","title":"Create New Project","type":"posts"},{"content":"","date":"11 August 2025","externalUrl":null,"permalink":"/tags/python/","section":"Tags","summary":"","title":"Python","type":"tags"},{"content":" 状态 图标 说明 完成 ✅ 任务已完成 进行中 🔄 正在处理 待处理 ⏳ 等待开始 错误 ❌ 出现问题 警告 ⚠️ 需要注意 未完成的任务 已完成的任务 另一个未完成的任务 特性 React Vue.js Angular 评分 学习曲线 中等 简单 复杂 Vue ⭐⭐⭐ 性能表现 优秀 优秀 良好 平分 ⭐⭐⭐ 生态系统 丰富 成长中 完整 React ⭐⭐⭐ 企业支持 Facebook 社区 Google Angular ⭐⭐⭐ 使用 Ctrl+Alt+Del 重启电脑\ngraph LR A[方形] --\u0026gt;B(圆角) B --\u0026gt; C{条件a} C --\u0026gt;|a=1| D[结果1] C --\u0026gt;|a=2| E[结果2] F[横向流程图] graph TD A[方形] --\u0026gt; B(圆角) B --\u0026gt; C{条件a} C --\u0026gt; |a=1| D[结果1] C --\u0026gt; |a=2| E[结果2] F[竖向流程图] st=\u0026gt;start: 开始框 op=\u0026gt;operation: 处理框 cond=\u0026gt;condition: 判断框(是或否?) sub1=\u0026gt;subroutine: 子流程 io=\u0026gt;inputoutput: 输入输出框 e=\u0026gt;end: 结束框 st(right)-\u0026gt;op(right)-\u0026gt;cond cond(yes)-\u0026gt;io(bottom)-\u0026gt;e cond(no)-\u0026gt;sub1(right)-\u0026gt;op 文本中的变量 $x = 5$ 和函数 $f(x) = x^2 + 2x + 1$。\n$$ \\begin{align} f(x) \u0026= ax^2 + bx + c \\\\ f'(x) \u0026= 2ax + b \\\\ f''(x) \u0026= 2a \\end{align} $$$$E = mc^2$$$$\\int_{-\\infty}^{\\infty} e^{-x^2} dx = \\sqrt{\\pi}$$ 张三 | 前端开发工程师 # 📞 联系方式 # 邮箱: zhangsan@email.com 电话: 138-0000-0000 GitHub: github.com/zhangsan LinkedIn: linkedin.com/in/zhangsan 地址: 上海市浦东新区 🎯 职业目标 # 具有 3 年前端开发经验的工程师，专注于 React 生态系统和现代化 Web 应用开发。寻求在创新型公司中担任高级前端开发职位，希望参与大型项目的架构设计和团队协作。\n💼 工作经验 # 高级前端开发工程师 | ABC 科技有限公司 # 2022.03 - 至今\n负责公司核心产品的前端开发，用户量达 100 万+ 使用 React、TypeScript 构建可维护的大型单页应用 与产品和设计团队协作，将设计稿转化为高质量的用户界面 建立前端组件库，提升团队开发效率 30% 技术栈: React, TypeScript, Redux, Webpack, Jest 前端开发工程师 | XYZ 互联网公司 # 2021.06 - 2022.02\n参与电商平台的前端开发和维护工作 优化页面性能，首屏加载时间减少 40% 负责移动端 H5 页面开发，适配多种设备 技术栈: Vue.js, JavaScript, SCSS, Element UI 🛠️ 技能清单 # 编程语言 # 熟练: JavaScript, TypeScript, HTML5, CSS3 了解: Python, Java, Go 前端框架 # React 生态: React, Redux, React Router, Next.js Vue 生态: Vue.js, Vuex, Vue Router, Nuxt.js 其他: Angular 基础 开发工具 # 版本控制 # Git, GitHub, GitLab 构建工具 # Webpack, Vite, Rollup Babel, PostCSS 测试工具 # Jest, Cypress, Testing Library 📱 联系方式 # 💼 工作经验 # 🎓 教育背景 # 🛠️ 技能清单 # 🚀 项目经历 # 🏆 获奖经历 # 📊 技能评估 # 技能类别 具体技能 熟练程度 前端框架 React ⭐⭐⭐⭐⭐ 前端框架 Vue.js ⭐⭐⭐⭐ 编程语言 TypeScript ⭐⭐⭐⭐ 编程语言 JavaScript ⭐⭐⭐⭐⭐ 🔗 在线作品 # ","date":"9 August 2025","externalUrl":null,"permalink":"/posts/learnmd/","section":"Posts","summary":"","title":"Publishing_process 博客发布流程","type":"posts"},{"content":"1.创建一篇新文章 打开Git Bash 终端，进入根目录d:/Blog\nhugo new content posts/hello-world.md\n告诉Hugo，在 content/posts/ 目录下，创建一个名为 hello-world.md 的新文章。\n2.编写文章内容\n打开VS Code，在 hello-world.md里面写内容 将draft：true改为draft：false 3.在本地预览效果\n回到Git Bash终端，运行： hugo server\n终端会启动一个本地服务器，并显示网址 http://localhost:1313/,打开网址浏览即可 预览完毕后，回到终端，按 Ctrl + C 组合键，停止本地服务器。 4.提交并推送到GitHub (自动发布)\n添加更改到暂存区 git add .\n提交更改到本地仓库 (创建一个新的提交记录) git commit -m \u0026ldquo;feat: Add my first post \u0026lsquo;Hello World\u0026rsquo;\u0026rdquo;\nfeat: 是一种规范的提交信息前缀，意思是“增加新功能”，这里指增加了新文章。\n写了一篇新文章？用 feat。\n修改了一篇文章的内容或错别字？用 docs。\n修正了一个导致网站显示不正常的Bug？用 fix。\n更新了 .gitignore 或者 deploy.yml？用 chore。\n推送到GitHub (这是触发自动部署的扳机) git push origin main\n5.检查线上部署\n打开浏览器，进入您之前创建的源码仓 (Blog-Source) 的GitHub页面。 点击页面上方的 “Actions” 选项卡。 您会看到一个新的工作流（Workflow）正在运行，它前面会有一个黄色的小圆圈。这就是GitHub在后台帮您生成和部署网站。 等待1-2分钟，当黄色圆圈变成绿色的对勾 (✓) 时，就代表您的网站已经部署成功了。 现在，请在浏览器中访问您的线上博客地址： https://\u0026lt;您的GitHub用户名\u0026gt;.github.io\n","date":"9 August 2025","externalUrl":null,"permalink":"/posts/publishing_process/","section":"Posts","summary":"","title":"Publishing_process 博客发布流程","type":"posts"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]