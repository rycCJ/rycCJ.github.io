[{"content":"本文 Docker 使用场景：电脑 A 上所有环境已经安装好，想要电脑 B 运行电脑 A 中的东西\nDocker 是什么？ # 1. Docker：一个开放源代码的平台 # Docker 是一个开源平台，它可以让你将应用程序及其所有依赖项（如库、系统工具、代码和运行时）打包到一个标准化的单元中，这个单元被称为容器。 这样，无论在任何环境下，你的应用程序都能以相同的方式运行。\n2. 容器 (Container)：轻量级的运行环境 # 容器是一个轻量级、可独立运行的软件包，其中包含了运行某个应用所需的一切：代码、运行时、系统工具、系统库和设置。容器在运行时相互隔离，也与底层的主机系统隔离，确保了环境的一致性。\n3. 镜像 (Image)：创建容器的模板 # 镜像是创建 Docker 容器的只读模板。它包含了应用程序代码以及运行该应用程序所需的所有工具、库和依赖项。你可以把镜像看作是容器的“蓝图”或“菜谱”。当你运行一个镜像时，就会创建一个该镜像的实例，也就是一个容器。\n4. Dockerfile：构建镜像的说明书 # Dockerfile 是一个文本文档，其中包含了一系列用户可以执行的指令，用于自动构建 Docker 镜像。Docker 会读取 Dockerfile 中的指令来一步步构建镜像。\n5. Docker 与虚拟机的区别 # 为了更好地理解 Docker，我们可以将它与传统的虚拟机（VM）进行比较：\n特性 Docker 容器 虚拟机 (VM) 虚拟化级别 操作系统级别虚拟化，共享主机内核 硬件级别虚拟化，每个 VM 都有自己的完整操作系统 资源消耗 资源消耗 轻量级，占用资源少，启动速度快（毫秒级） 资源密集型，需要加载完整的操作系统，启动速度慢（分钟级） 隔离性 进程级别隔离，安全性相对较低 完全隔离，每个 VM 都是一个独立的系统，安全性高 大小 镜像通常较小（MB 级别） 虚拟机镜像通常很大（GB 级别） 简单来说，虚拟机是在模拟一台完整的计算机，而 Docker 容器更像是运行在现有操作系统上的一个被隔离的进程。\n第一步：下载与安装 # 在两台电脑上下载好 Docker，视频教程 [对应的文本教程}(https://github.com/tech-shrimp/docker_installer) (完成步骤 1，2 即可)\n下载完成后，打开终端，在两台电脑测试：\ndocker --version 如果能看到版本号，说明一切准备就绪。\n第二步： 运行第一个 Docker 容器 # 尝试拉取一个镜像，并且使用镜像运行交互式容器，最后尝试推出并且自动销毁一个容器。\n1.拉取（下载）一个镜像\n镜像是创建容器的模板。我们需要先从一个名为 Docker Hub 的公共镜像仓库中获取我们想要的镜像。Docker Hub 上存储了成千上万个官方和社区创建的镜像。 现在，拉取官方的 Ubuntu 镜像。在终端中输入以下命令：\ndocker pull ubuntu 下载完成后，可以使用以下命令查看你本地已经拥有的所有镜像：\ndocker images 2.运行（启动）一个容器 有了 ubuntu 镜像，就可以用它来创建一个容器了。这就像是用 Ubuntu 的安装盘（镜像）来启动一台新的电脑（容器）。\n在终端中输入以下命令：\ndocker run -it --rm ubuntu bash docker run: 这是运行一个容器的命令。 -it: 这是两个参数的组合： -i (\u0026ndash;interactive): 保持标准输入（STDIN）打开，允许你与容器进行交互。 -t (\u0026ndash;tty): 分配一个伪终端或终端。简单来说，就是让你能看到一个命令提示符。 -it，就是我们常说的“交互式终端”，它能让你像操作一台真实的 Linux 机器一样在容器里输入命令。 \u0026ndash;rm: 这个参数表示当容器退出时，自动将它删除。这对于我们进行快速测试非常方便，可以避免留下很多无用的容器。 ubuntu: 这是我们想要使用的镜像的名称。 bash: 这是我们希望在容器启动时执行的命令。bash 是 Ubuntu 系统中最常见的命令行 Shell。 当你执行完这条命令后，你会发现你的命令提示符变了！它可能看起来像这样：\nroot@xxxxxxxxxxxx:/# 现在已经在一个运行着 Ubuntu 的 Docker 容器内部了！ 这完全是在 Windows 系统上原生运行的，但你得到的却是一个隔离的、完整的 Ubuntu 文件系统和命令行环境。\n3. 在容器内进行交互\n可以在这个终端里尝试一些常见的 Linux 命令，感受一下： 查看当前目录下的文件： ls 查看操作系统版本： cat /etc/os-release 更新软件包列表： apt-get update\n4.退出容器 当完成实验后，只需在容器的终端里输入 exit 或者按下 Ctrl + D，就会退出这个容器。\n因为我们之前使用了 \u0026ndash;rm 参数，所以在你退出后，这个容器就被自动删除了。你可以通过 docker ps -a 命令来确认（-a会显示所有容器，包括已经停止的），会发现那个容器已经不见了。\n第三步：定制自己的环境 (Dockerfile) # Dockerfile 是一个文本文件，它像一份“安装说明书”，告诉 Docker 如何一步步地构建一个镜像。我们通过在其中写入指令（如安装软件、复制文件等）来定制我们的环境。\n核心指令 # FROM: 指定一个基础镜像，我们的构建将从这个镜像开始。例如 FROM ubuntu:22.04。 RUN: 执行一条命令。主要用于在镜像内部安装软件。例如 RUN apt-get update \u0026amp;\u0026amp; apt-get install -y python3。 WORKDIR: 设置工作目录，后续的指令都会在这个目录下执行。例如 WORKDIR /app。 COPY: 将你电脑上的文件或文件夹复制到镜像中。例如 COPY . . 表示将当前目录所有文件复制到镜像的当前工作目录。 CMD: 指定容器启动时默认执行的命令。例如 CMD [\u0026#34;bash\u0026#34;]。 操作任务 # 假设你的实验环境需要Python和Git。现在，我们在电脑 A 上创建一个包含这两个工具的自定义镜像 1.创建一个项目文件夹：在电脑 A 上，创建一个新的文件夹，例如 my-lab-env，然后进入这个文件夹。 2.创建 Dockerfile：在 my-lab-env 文件夹中，创建一个名为 Dockerfile (没有文件后缀) 的文件，用记事本或任何代码编辑器打开它，并输入以下内容：\n# 使用官方的Ubuntu 22.04作为基础镜像 FROM ubuntu:22.04 # 设置一个环境变量，避免安装时出现交互式提示 ENV DEBIAN_FRONTEND=noninteractive # 更新软件包列表，并安装python3, pip, 和 git # 使用 \u0026amp;\u0026amp; 连接命令，可以减小镜像层数 RUN sed -i \u0026#39;s/archive.ubuntu.com/mirrors.aliyun.com/g\u0026#39; /etc/apt/sources.list \u0026amp;\u0026amp; \\ apt-get update \u0026amp;\u0026amp; apt-get install -y \\ python3 \\ python3-pip \\ git \\ \u0026amp;\u0026amp; apt-get clean \u0026amp;\u0026amp; rm -rf /var/lib/apt/lists/* # 设置工作目录为 /app WORKDIR /app # 当容器启动时，默认执行bash命令，进入交互式终端 CMD [\u0026#34;bash\u0026#34;] 构建镜像：打开终端（PowerShell 或 CMD），确保正处于 my-lab-env 文件夹内。然后执行以下命令来构建第一个自定义镜像： # -t 参数用来给镜像命名和打标签，格式为 \u0026#39;名称:版本号\u0026#39; # \u0026#39;.\u0026#39; 表示Dockerfile在当前目录下 docker build -t my-lab-image:1.0 . 验证镜像：构建完成后，运行 docker images，看到刚刚创建的 my-lab-image:1.0。\n运行自定义容器：现在，用新镜像启动一个容器：\ndocker run -it --rm my-lab-image:1.0 进入容器后，可以分别输入 python3 --version 和 git --version 来验证软件是否已经成功安装。然后输入 exit 退出。\n第四步：让数据持久化 (Volumes) # 容器本身是“无状态”的，默认情况下，你在容器里做的所有文件修改都会随着容器的删除而消失。为了保存你的工作，我们需要使用数据卷 (Volume)。数据卷可以将主机上的一个文件夹映射到容器里的一个文件夹。这样，你在容器里对这个文件夹做的任何修改，都会实时同步到电脑的文件夹里，反之亦然。\n操作任务： # 在主机上创建工作区：在电脑 A 的 my-lab-env 文件夹内，再创建一个名为 workspace 的子文件夹。这个文件夹将用来存放项目代码。\n使用 -v 参数运行容器：现在，再次启动容器，但这次加上 -v 参数来挂载数据卷。\n# -v \u0026#34;你电脑上的绝对路径\u0026#34;:\u0026#34;容器内的绝对路径\u0026#34; # Windows CMD: docker run -it --rm -v \u0026#34;%cd%\\workspace:/app\u0026#34; my-lab-image:1.0 #若想把项目换成存放在 D:\\my_coding_projects\\robotics_simulation #则上面命令需要修改为：docker run -it --rm -v \u0026#34;D:\\my_coding_projects\\robotics_simulation:/app\u0026#34; my-lab-image:1.0 # Windows PowerShell: docker run -it --rm -v \u0026#34;${pwd}\\workspace:/app\u0026#34; my-lab-image:1.0 这个命令的意思是：将当前目录下的 workspace 文件夹，映射到容器内的/app 目录（在 Dockerfile 中设置的工作目录）。 验证数据持久化： 进入容器后，你现在正处于 /app 目录下。执行 ls，你会发现它是空的。 在容器内创建一个文件：echo \u0026ldquo;hello from container\u0026rdquo; \u0026gt; test.txt。 现在，不要退出容器，去你电脑的 my-lab-env\\workspace 文件夹下查看，你会惊喜地发现里面多了一个 test.txt 文件，内容正是你刚刚写入的！ 现在，在容器外，用记事本打开这个 test.txt，修改内容为 hello from host 并保存。 回到容器的终端，执行 cat test.txt，你会看到内容已经变成了 hello from host。 最后，输入 exit 退出并删除容器。但你电脑上 workspace 文件夹里的 test.txt 文件依然存在。你的工作被成功保存了！ 第五步：分享与同步你的环境 (Docker Hub) # Docker Hub 是一个公共的镜像注册中心，你可以把它想象成 Docker 镜像的 GitHub。你可以将你在本地构建的镜像推送到 Docker Hub，然后在世界上任何一台安装了 Docker 的机器上把它拉取下来。\n操作任务： # 注册 Docker Hub 账号：访问 https://hub.docker.com/ 并注册一个免费账号。记住你的用户名。 在电脑A上登录：打开终端，输入 docker login 命令，然后按照提示输入你的用户名和密码。 给镜像打上正确的标签：要将镜像推送到你的仓库，必须按照 你的用户名/镜像名:版本号 的格式重新给它打标签。 # docker tag \u0026lt;本地镜像名:版本号\u0026gt; \u0026lt;你的用户名/远程仓库名:版本号\u0026gt; docker tag my-lab-image:1.0 your-dockerhub-username/my-lab-env:1.0 推送镜像：现在，将你打好标签的镜像推送到 Docker Hub。 docker push your-dockerhub-username/my-lab-env:1.0 在电脑 B 上拉取镜像：现在，切换到电脑 B。 同样，先在终端执行 docker login 登录账号。 然后执行docker pull命令来拉取你刚刚推送的镜像： docker pull your-dockerhub-username/my-lab-env:1.0 第六步：网络连接 (Port Mapping) # 默认情况下，容器的网络是与外界隔离的。如果在容器里运行了一个需要通过浏览器访问的应用（比如一个 Jupyter Notebook 服务或者一个网站服务器），则需要把容器的端口“暴露”给主机的端口。\n操作任务： # 运行一个 Web 服务：在自定义的容器里运行一个简单的 Python Web 服务器。用电脑 B 上拉取下来的镜像启动容器： # -p \u0026lt;主机端口\u0026gt;:\u0026lt;容器端口\u0026gt; # 我们将主机的8888端口映射到容器的8000端口 docker run -it --rm -p 8888:8000 your-dockerhub-username/my-lab-env:1.0 在容器内启动服务：进入容器后，在 /app 目录下创建一个简单的网页文件： echo \u0026#34;\u0026lt;h1\u0026gt;Hello Docker!\u0026lt;/h1\u0026gt;\u0026#34; \u0026gt; index.html 然后启动 Python 内置的 HTTP 服务器，它默认在 8000 端口上运行：\npython3 -m http.server 8000 从主机浏览器访问：现在，打开电脑 B 上的任何浏览器（Chrome, Edge 等），访问 http://localhost:8888。 应该能看到 \u0026ldquo;Hello Docker!\u0026rdquo; 的字样。 成功地将容器内的网络服务暴露给了你的主机！ 第七步：整合所有操作 (最终工作流) # 在电脑 A 上（当环境有变化时候） # 更新环境：如果需要安装新的软件，就去修改 my-lab-env 文件夹里的 Dockerfile 重新构建：修改后，构建一个新的镜像，可以给它一个新的版本号，例如 1.1 docker build -t my-lab-image:1.1 . 打标签并推送：给新镜像打上Docker Hub标签并推送。 docker tag my-lab-image:1.1 your-dockerhub-username/my-lab-env:1.1 docker push your-dockerhub-username/my-lab-env:1.1 在电脑 B 上 # 拉取最新环境：定期从 Docker Hub 拉取你最新的环境镜像。 docker pull your-dockerhub-username/my-lab-env:1.1 准备项目文件夹：在电脑 B 上创建一个项目文件夹，例如 D:\\my-projects\\project-A 启动开发容器：使用 docker run 命令，挂载你的项目文件夹，并映射可能需要的端口。 # 示例: 挂载项目文件夹并映射8888端口 docker run -it --rm -v \u0026#34;D:\\my-projects\\project-A:/app\u0026#34; -p 8888:8000 your-dockerhub-username/my-lab-env:1.1 现在，你可以在这个容器里进行所有的开发、编译、运行等工作。电脑 B 上除了Docker之外，不需要安装任何其他的开发工具、库或依赖。代码和文件都安全地保存在 D:\\my-projects\\project-A 文件夹中\n","date":"25 October 2025","externalUrl":null,"permalink":"/posts/docker%E5%AE%8C%E6%95%B4%E6%8C%87%E5%8D%97/","section":"Posts","summary":"在这里写下您的文章摘要\u0026hellip;","title":"Docker完整指南","type":"posts"},{"content":"","date":"25 October 2025","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"25 October 2025","externalUrl":null,"permalink":"/","section":"Welcome to My Blog","summary":"","title":"Welcome to My Blog","type":"page"},{"content":"","date":"18 October 2025","externalUrl":null,"permalink":"/tags/algorithm/","section":"Tags","summary":"","title":"Algorithm","type":"tags"},{"content":"","date":"18 October 2025","externalUrl":null,"permalink":"/tags/c++/","section":"Tags","summary":"","title":"C++","type":"tags"},{"content":"","date":"18 October 2025","externalUrl":null,"permalink":"/notes/","section":"Notes","summary":"","title":"Notes","type":"notes"},{"content":"","date":"18 October 2025","externalUrl":null,"permalink":"/tags/recursion/","section":"Tags","summary":"","title":"Recursion","type":"tags"},{"content":"","date":"18 October 2025","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":" 108. 将有序数组转换为二叉搜索树 # class Solution { public: TreeNode* sortedArrayToBST(vector\u0026lt;int\u0026gt;\u0026amp; nums) { return help(nums,0,nums.size()-1); } TreeNode* help(vector\u0026lt;int\u0026gt;\u0026amp; nums, int left, int right) { if (left \u0026gt; right) { //左右相同的下一步就是左边大于右边，左右相同得放进树里面 return nullptr; } int mid = (left + right + 1) / 2; TreeNode* root = new TreeNode(nums[mid]); root-\u0026gt;left = help(nums, left, mid - 1); root-\u0026gt;right = help(nums, mid + 1, right); return root; } }; 98. 验证二叉搜索树 # 方案 1：中序遍历（推荐的简洁方法）\n核心原理： 对一个二叉搜索树（BST）进行中序遍历（左 → 根 → 右），得到的节点值序列一定是严格递增的。\nclass Solution { private: // 必须用成员变量或引用参数来维护这个状态 long long prevVal = LLONG_MIN; public: bool isValidBST(TreeNode* root) { if (root == nullptr) { return true; } // 1. 递归检查左子树 if (!isValidBST(root-\u0026gt;left)) { return false; } // 2. 检查当前节点（中序遍历的核心逻辑） // 核心：当前值必须严格大于上一个值 if (root-\u0026gt;val \u0026lt;= prevVal) { return false; } // 3. 更新上一个值 prevVal = root-\u0026gt;val; // 4. 递归检查右子树 return isValidBST(root-\u0026gt;right); } }; 方案 2：上下限递归（更基础的方法）\nclass Solution { public: bool isValidBST(TreeNode* root) { return helper(root,LLONG_MIN,LLONG_MAX); } bool helper(TreeNode* root, long long lower, long long upper) { if (root == nullptr) return true; if (root-\u0026gt;val \u0026lt;= lower || root-\u0026gt;val \u0026gt;= upper) return false; bool left = helper(root-\u0026gt;left, lower, root-\u0026gt;val); bool right = helper(root-\u0026gt;right, root-\u0026gt;val, upper); return left \u0026amp;\u0026amp; right; } }; 230. 二叉搜索树中第 K 小的元素 # class Solution { public: int kthSmallest(TreeNode* root, int k) { vector\u0026lt;int\u0026gt; result; helper(root,result); return result[k-1]; } void helper(TreeNode* root, vector\u0026lt;int\u0026gt;\u0026amp; res) { if (root == nullptr) return; helper(root-\u0026gt;left,res); res.push_back(root-\u0026gt;val); helper(root-\u0026gt;right,res); } }; 使用布尔信号提前终止\nclass Solution { public: int kthSmallest(TreeNode* root, int k) { vector\u0026lt;int\u0026gt; result; helper(root, result, k); return result[k - 1]; } bool helper(TreeNode* root, vector\u0026lt;int\u0026gt;\u0026amp; res, int n) { // 递归终止条件 1: 节点为空，返回 false (继续遍历) if (root == nullptr) return false; // 递归终止条件 2: 已经找到 K 个元素，直接返回 true (停止) if (res.size() == n) { return true; } if (helper(root-\u0026gt;left, res, n)) return true; res.push_back(root-\u0026gt;val); if (res.size() == n) { return true; } return helper(root-\u0026gt;right, res, n); } }; 114. 二叉树展开为链表 # 方法一：普通方法（递归）\nclass Solution { public: void flatten(TreeNode* root) { vector\u0026lt;TreeNode*\u0026gt; res; help(root, res); int n = res.size(); for (int i = 0; i \u0026lt; n-1; i++) { TreeNode* node = res[i]; node-\u0026gt;left =nullptr; node-\u0026gt;right = res[i+1]; } } void help(TreeNode* root, vector\u0026lt;TreeNode*\u0026gt;\u0026amp; res) { if (root != nullptr) { res.push_back(root); help(root-\u0026gt;left, res); help(root-\u0026gt;right, res); } } }; 方法二：递归/逆向先序遍历 (Right → Left → Root)\nclass Solution { public: void flatten(TreeNode* root) { help(root); } TreeNode* pre = nullptr; void help(TreeNode* root) { if (root == nullptr) { return; } help(root-\u0026gt;right); help(root-\u0026gt;left); root-\u0026gt;right = pre; root-\u0026gt;left = nullptr; pre = root; return; } }; 方法三：迭代 + 寻找前驱 (Morris Traversal 思想) //看不懂思密达\nclass Solution { public: void flatten(TreeNode* root) { TreeNode* curr = root; while (curr != nullptr) { // 1. 如果有左子树 if (curr-\u0026gt;left != nullptr) { // 2. 找到左子树的最右节点 (前驱 predecessor) TreeNode* predecessor = curr-\u0026gt;left; while (predecessor-\u0026gt;right != nullptr) { predecessor = predecessor-\u0026gt;right; } // 3. 关键连接：将右子树接在左子树的末尾 predecessor-\u0026gt;right = curr-\u0026gt;right; // 4. 重排：将左子树整体搬到右侧 curr-\u0026gt;right = curr-\u0026gt;left; curr-\u0026gt;left = nullptr; // 清空左指针 } // 5. 前进到下一个节点（即原先的右子树或新的右子树的根） curr = curr-\u0026gt;right; } } }; ","date":"18 October 2025","externalUrl":null,"permalink":"/notes/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB/","section":"Notes","summary":"","title":"二叉树题目汇总","type":"notes"},{"content":"","date":"26 September 2025","externalUrl":null,"permalink":"/tags/git/","section":"Tags","summary":"","title":"Git","type":"tags"},{"content":"Learn Git Branching学习总结\n提交 # git commit git branch \u0026lt;name\u0026gt; //添加分支 git checkout \u0026lt;name\u0026gt; //切换到分支 git checkout -b bugFix //新建并且切换 合并分支 # 方法一：使用git merge合并两个分支 git checkout -b bugFix //新建并且切换 git commit git checkout main git commit //提交main git merge bugFix //将bugFix合并进main 方法二：使用git rebase合并两个分支 git checkout -b bugFix //新建并且切换 git commit git checkout main git commit git checkout bugFix git rebase main Head # 我们首先看一下 HEAD。 HEAD 是一个对当前所在分支的符号引用 —— 也就是指向你正在其基础上进行工作的提交记录。\nHEAD 总是指向当前分支上最近一次提交记录。大多数修改提交树的 Git 命令都是从改变 HEAD 的指向开始的。\nHEAD 通常情况下是指向分支名的（如 bugFix）。在你提交时，改变了 bugFix 的状态，这一变化通过 HEAD 变得可见。\n如果想看 HEAD 指向，可以通过 cat .git/HEAD 查看， 如果 HEAD 指向的是一个引用，还可以用 git symbolic-ref HEAD 查看它的指向\n相对引用 ^ # 使用^向上移动 1 个提交记录;使用~\u0026lt;num\u0026gt; 向上移动多个提交记录，如 ~3\n让分支指向另一个提交 例如 :\ngit checkout main^ git branch -f main HEAD~3 git branch -f three C2 //让three指向C2 会将 main 分支强制指向 HEAD 的第 3 级 parent 提交。\n撤销变更 # git reset HEAD~1 //当前分支撤销到上一级，仅在本地 git revert C1 //当前分支添加一个新的分支，里面的操作可为撤销，可以远程 git revert C1 //撤销到 C1 整理提交记录 # git cherry-pick \u0026lt;提交号\u0026gt;... git cherry-pick C2 C4` 将 C2 C4（分支上的 指的是哈希值）复制到 main（当前分支）分支 git cherry-pick xx ` 可以将提交树上任何地方的提交记录取过来追加到 HEAD 上 交互式的 rebase git rebase -i HEAD~4//对 HEAD~4 之后的提交修改顺序 创建标签 # git tag v1 C1 git tag v1 main~2(main 的上两级) //建立一个标签，指向提交记录 C1，表示这是我们 1.0 版本 git describe \\\u0026lt;ref\u0026gt;\n\u0026lt;ref\u0026gt; 可以是任何能被 Git 识别成提交记录的引用，如果你没有指定的话，Git 会使用你目前所在的位置（HEAD）。\n它输出的结果是这样的：\u0026lt;tag\u0026gt;_\u0026lt;numCommits\u0026gt;_g\u0026lt;hash\u0026gt;\ntag 表示的是离 ref 最近的标签， numCommits 是表示这个ref与tag相差有多少个提交记录， hash 表示的是你所给定的 ref 所表示的提交记录哈希值的前几位。\n当 ref 提交记录上有某个标签时，则只输出标签名称\n两个 parent 节点 # 若有两个 parnet 节点，HEAD^ 代表第一个 parnet 节点，HEAD^2 代表另一个不近的节点。\ngit checkout HEAD^2 //去到当前分支的较远的 parent 节点 git branch bugWork main^^2^ //创建 bugWork 并且移动到 main 父节点的第二个父节点的父节点 偏离的提交历史 # 假设你周一克隆了一个仓库，然后开始研发某个新功能。到周五时，你新功能开发测试完毕，可以发布了。但是 —— 天啊！你的同事这周写了一堆代码，还改了许多你的功能中使用的 API，这些变动会导致你新开发的功能变得不可用。但是他们已经将那些提交推送到远程仓库了，因此你的工作就变成了基于项目旧版的代码，与远程仓库最新的代码不匹配了。\ngit fetch; //更新了本地仓库中的远程分支 git rebase o/main; //将我们的工作移动到最新的提交记录下 git push //推送到远程仓库 也可以使用 merge\ngit fetch; //更新了本地仓库中的远程分支 git merge o/main; //将合并了新变更到我们的本地分支（为了包含远程仓库的变更 git push //推送到远程仓库 git pull 就是 fetch 和 merge 的简写，类似的 git pull --rebase 就是 fetch 和 rebase 的简写\n远程服务器拒绝!(Remote Rejected) # 远程服务器拒绝直接推送(push)提交到 main, 因为策略配置要求 pull requests 来提交更新.\n你应该按照流程,新建一个分支, 推送(push)这个分支并申请 pull request,但是你忘记并直接提交给了 main.现在你卡住并且无法推送你的更新\n新建一个分支 feature, 推送到远程服务器. 然后 reset 你的 main 分支和远程服务器保持一致, 否则下次你 pull 并且他人的提交和你冲突的时候就会有问题.\ngit branch -f main o/main git checkout -b feature C2 git push origin feature 合并多个分支 # git fetch git rebase o/main side1 git rebase side1 side2 git rebase side2 side3 git push ","date":"26 September 2025","externalUrl":null,"permalink":"/posts/git%E5%AD%A6%E4%B9%A0/","section":"Posts","summary":"Learn Git Branching学习总结","title":"Git学习","type":"posts"},{"content":"B 站“灵茶山艾府“的解释\n递归的核心思想：不是人肉压栈，而是“甩锅” # 初学者的困境：人肉模拟调用栈\n当递归层数很少时，比如三层，你还能模拟：main 调用 A，A 调用 B，B 调用 C。C 返回给 B，B 返回给 A，A 返回给 main。但当层数一多，你的大脑就会像计算机内存溢出一样，难以追踪。\n正确的递归思维方式是“信任”或者叫“信念之跃”（Leap of Faith）。\n你只需要关注两件事：\n1.终止条件（Base Case）：什么时候问题小到可以直接解决，不需要再“甩锅”给下一层了？\n2.递归关系（Recursive Relation）：如何把当前问题，分解成一个或多个规模更小的同类子问题，并假设（信任）下一层调用能完美解决这些子问题。然后，你只需要思考如何利用子问题的解来组合成当前问题的解。\n**你不需要去想下一层是怎么实现的，你只要相信它能给你正确的结果就行了。**就像调用一个库函数sort()，你不会去关心它内部是快排还是归并.\n把递归函数本身，也当成一个黑盒的、可信赖的库函数来调用。\n以二叉树为例 # #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; // 定义二叉树节点 struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} }; /* 我们来定义函数 maxDepth(root) 它的功能是：接收一个树的根节点，返回这棵树的最大深度。 */ int maxDepth(TreeNode* root) { // 1. 终止条件 (Base Case) // 如果这个节点是空的（比如一个叶子节点的子节点）， // 那么它构成的树深度就是 0。这是最简单、可以直接回答的问题。 if (root == nullptr) { return 0; } // 2. 递归关系 (Recursive Relation) // 对于任何一个非空的节点 root，它的最大深度是多少？ // 我们可以把它分解成两个子问题： // - 左子树的最大深度是多少？ // - 右子树的最大深度是多少？ // 这两个子问题的规模都比当前问题（整棵树的深度）要小。 // 而且它们是同类问题：都是“计算一棵树的最大深度”。 // 所以，我们可以“甩锅”了！ // 我假设 maxDepth() 这个函数已经能完美工作了（信念之跃）。 // 我把它当成一个已知的、可靠的工具来调用。 // 我“相信”下面这行代码能正确计算出左子树的深度。 // 我不去想 aleftDepth 是怎么一步步算出来的。 int leftDepth = maxDepth(root-\u0026gt;left); // 我同样“相信”这行代码能正确计算出右子树的深度。 int rightDepth = maxDepth(root-\u0026gt;right); // 3. 组合子问题的解 // 现在，我已经拿到了两个子问题的答案：leftDepth 和 rightDepth。 // 如何用这两个答案来解决我当前的问题（以 root 为根的树的深度）？ // 很显然，整棵树的深度 = 左右子树深度的较大者 + 1 (当前这一层) return std::max(leftDepth, rightDepth) + 1; } int main() { /* 构造一棵树: 3 / \\ 9 20 / \\ 15 7 */ TreeNode* root = new TreeNode(3); root-\u0026gt;left = new TreeNode(9); root-\u0026gt;right = new TreeNode(20); root-\u0026gt;right-\u0026gt;left = new TreeNode(15); root-\u0026gt;right-\u0026gt;right = new TreeNode(7); std::cout \u0026lt;\u0026lt; \u0026#34;这棵树的最大深度是: \u0026#34; \u0026lt;\u0026lt; maxDepth(root) \u0026lt;\u0026lt; std::endl; // 应该输出 3 delete root-\u0026gt;left; delete root-\u0026gt;right-\u0026gt;left; delete root-\u0026gt;right-\u0026gt;right; delete root-\u0026gt;right; delete root; return 0; } 如何正确思考 maxDepth(root) 的过程？\n1.我的目标：实现 maxDepth(root) 函数。\n2.第一步：找终止条件。 什么情况下最简单？树是空的！if (root == nullptr)，深度就是 0。搞定。\n3.第二步：找递归关系。 如果树不空，root 指向一个节点。这棵树的深度和它的左右孩子有什么关系？\n左子树的深度。\n右子树的深度。\n整棵树的深度就是 max(左深度, 右深度) + 1。\n4.第三步：写代码（信念之跃）。 如何获取左子树的深度？直接调用maxDepth(root-\u0026gt;left)。相信它！ 不要去想它内部是怎么对 root-\u0026gt;left 的子节点进行递归的。就把它当成 int leftDepth = getLeftDepth() 这么一个普通的函数调用。\n如何获取右子树的深度？同理，调用 maxDepth(root-\u0026gt;right)。相信它！\n拿到 leftDepth 和 rightDepth 后，根据第二步的分析，return std::max(leftDepth, rightDepth) + 1;。\n整个思考过程，我们只关注“当前层”的逻辑。 我们把对子树的处理完全委托给了递归调用，我们是“管理者”，不是“微观执行者”。\n再举一例：二叉树的前序遍历 # 前序遍历的顺序是：根 -\u0026gt; 左 -\u0026gt; 右。这个定义本身就充满了递归的味道\nvoid preOrderTraversal(TreeNode* root) { // 1. 终止条件 if (root == nullptr) { return; // 空树就直接返回，什么也不做 } // 2. 处理当前节点 (根) std::cout \u0026lt;\u0026lt; root-\u0026gt;val \u0026lt;\u0026lt; \u0026#34; \u0026#34;; // 访问根节点 // 3. 递归处理左子树 (左) // “信念之跃”：我相信这个调用会完美地以前序遍历的方式打印完整个左子树 preOrderTraversal(root-\u0026gt;left); // 4. 递归处理右子树 (右) // “信念之跃”：我相信这个调用会完美地以前序遍历的方式打印完整个右子树 preOrderTraversal(root-\u0026gt;right); } 正确思考 preOrderTraversal：\n1.我的目标：按“根-左-右”的顺序打印树。\n2.终止条件：root 是 nullptr，没什么可打印的，直接 return。\n3.当前层的逻辑：如果 root 不是 nullptr，根据“根-左-右”的定义，我应该：\n先处理“根”：cout \u0026lt;\u0026lt; root-\u0026gt;val;\n然后处理“左”：怎么处理？这是一个规模更小的同类问题，直接调用 preOrderTraversal(root-\u0026gt;left); 来搞定整个左子树。相信它能行！\n最后处理“右”：同理，调用 preOrderTraversal(root-\u0026gt;right); 来搞定整个右子树。相信它也能行！\n代码和逻辑完全一一对应，清晰明了。 你根本不需要去想，调用 preOrderTraversal(root-\u0026gt;left)之后，它又会怎么打印，怎么调用它的左孩子和右孩子。你只要相信这个函数的功能定义是正确的，你调用它，它就能完成任务。\n总结与建议 # 明确函数定义：在写递归函数之前，用一句话清晰地描述这个函数的功能。例如：“maxDepth(node)的功能是返回以 node 为根的子树的最大深度”。在后续的递归调用中，始终坚信你调用的就是这个已经实现的功能。\n只考虑当前层：你的所有逻辑都应该只围绕“当前节点”展开。你需要做什么？你需要从子问题的解中得到什么信息？你如何利用这些信息？\n找到终止条件：思考什么情况下问题规模最小，可以被直接解决，不再需要递归。这是递归的出口，没有它就会无限循环，导致“栈溢出”。\n信任递归调用：这是最关键的一步。当你对 function(sub_problem) 进行调用时，就把它当成一个已知的、正确的黑盒。你的任务不是去追踪它的执行，而是去使用它的返回结果。\n当你下次再遇到一个递归问题时，请抑制住你的大脑去模拟整个调用栈的冲动。强迫自己用上面的思维模式去思考，多练习几次，你会发现递归问题会变得异常清晰和简单。它是一种将复杂问题分解为简单、重复单元的强大思维工具。\n1. 基础遍历类 # 这类问题的核心是“访问”到每一个节点并执行简单操作，递归函数本身通常没有返回值（void）或者返回一个包含所有节点值的列表。\n核心思路： 定义一个 traverse(node) 函数，在函数内部先处理当前节点，然后递归调用 traverse(node-\u0026gt;left) 和 traverse(node-\u0026gt;right)。根据处理当前节点的时机不同，分为前、中、后序遍历。\n经典题目:\n144. 二叉树的前序遍历 # class Solution { public: void perorder(TreeNode* root, vector\u0026lt;int\u0026gt;\u0026amp; res) { if (root == nullptr) return; res.push_back(root-\u0026gt;val); perorder(root-\u0026gt;left, res); perorder(root-\u0026gt;right, res); } vector\u0026lt;int\u0026gt; preorderTraversal(TreeNode* root) { vector\u0026lt;int\u0026gt; res; perorder(root, res); return res; } }; 94. 二叉树的中序遍历 # class Solution { public: void inorder(TreeNode *node, vector\u0026lt;int\u0026gt; \u0026amp;res) { if (node == nullptr) return; inorder(node-\u0026gt;left, res); res.push_back(node-\u0026gt;val); inorder(node-\u0026gt;right, res); } vector\u0026lt;int\u0026gt; inorderTraversal(TreeNode *root) { vector\u0026lt;int\u0026gt; res; inorder(root, res); return res; } }; 145. 二叉树的后序遍历 # class Solution { public: void postorder(TreeNode* root, vector\u0026lt;int\u0026gt;\u0026amp; res) { if (root == nullptr) return; postorder(root-\u0026gt;left, res); postorder(root-\u0026gt;right, res); res.push_back(root-\u0026gt;val); } vector\u0026lt;int\u0026gt; postorderTraversal(TreeNode* root) { vector\u0026lt;int\u0026gt; res; postorder(root, res); return res; } }; 2. 分治 / 自下而上信息汇总 # 这是最最常见的一类递归问题。你相信递归函数能帮你解决子问题，然后你只需要思考如何利用子问题的解来解决当前问题。\n核心思路 ： “我不知道怎么解决整棵树的问题，但我假设 solve(root-\u0026gt;left) 和 solve(root-\u0026gt;right) 已经帮我解决了左右子树的问题并返回了正确的结果。现在，我只需要在当前 root 节点，利用这两个结果，计算出当前树的结果，然后 return 回去。”\n经典题目:\n104. 二叉树的最大深度 # 我们之前讨论过的\n左子树深度 = solve(root-\u0026gt;left), 右子树深度 = solve(root-\u0026gt;right)\n当前树深度 = max(左子树深度, 右子树深度) + 1\n111. 二叉树的最小深度 # 最大深度的变体，注意处理只有单边子树的情况\nint minDepth(TreeNode* root) { if (root == nullptr) return 0; int ldepth = minDepth(root-\u0026gt;left); int rdepth = minDepth(root-\u0026gt;right); if (root-\u0026gt;right == nullptr) { return ldepth+1; } if (root-\u0026gt;left == nullptr) { return rdepth+1; } return min(ldepth, rdepth) + 1; } 543. 二叉树的直径 # 子问题返回子树的深度。\n当前节点计算的“穿过我的直径”是 左深度 + 右深度，同时更新全局最大值。\nint landrDepth(TreeNode* root,int\u0026amp; maxdepth) { if (root == nullptr) return 0; int ldepth = landrDepth(root-\u0026gt;left,maxdepth); int rdepth = landrDepth(root-\u0026gt;right,maxdepth); int currentdepth = ldepth + rdepth; maxdepth = max(maxdepth,currentdepth); return max(ldepth,rdepth)+1; } int diameterOfBinaryTree(TreeNode* root) { int maxdepth=0; landrDepth(root,maxdepth); return maxdepth; } 124. 二叉树中的最大路径和 # (其他路径问题在第三部分) 辅助函数的主要功能是求解单边最大，这样计算左右两边最大就可以得到想要的最大值。 不要拘泥于辅助函数必须返回目标值，这种直接得到目标值行不通的，可以考虑分解目标，但是将目标值存储在变量中。\nint globalmax = numeric_limits\u0026lt;int\u0026gt;::min(); int cacule2(TreeNode \\*root) { if (root == nullptr) return 0; int lmax = max(0,cacule2(root-\u0026gt;left)); int rmax = max(0,cacule2(root-\u0026gt;right)); int currentnum = root-\u0026gt;val + lmax + rmax; globalmax = max(currentnum, globalmax); return root-\u0026gt;val+max(lmax,rmax); } int maxPathSum(TreeNode \\*root) { globalmax = numeric_limits\u0026lt;int\u0026gt;::min(); cacule2(root); return globalmax; } 110. 平衡二叉树 # 引入-1，蛮有意思\u0026hellip;\u0026hellip;\n子问题需要返回两个信息：子树是否平衡，以及子树的高度。\nclass Solution { public: bool isBalanced(TreeNode* root) { return dep(root)!=-1; } int dep(TreeNode* root) { if(root==nullptr){ return 0; } int ldepth = dep(root-\u0026gt;left); if(ldepth==-1){ return -1; } int rdepth = dep(root-\u0026gt;right); if(rdepth==-1){ return -1; } // chazhi = max(chazhi,abs(ldepth - rdepth)); if(abs(ldepth - rdepth)\u0026gt;1){ return -1; } return max(ldepth,rdepth)+1; } }; 236.二叉树的最近公共祖先 # 子问题返回在子树中是否找到了 p 或 q。\n当前节点根据左右子树的返回情况做出判断。\n把一个复杂的“寻找 LCA”问题，降维成了一个简单的“寻找 p 或 q”的问题 emmm 怪有意思\u0026hellip;\u0026hellip;\nTreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { //如果你确定树中所有节点的值唯一（比如二叉搜索树 BST 中常常是这样），那用 root-\u0026gt;val == p-\u0026gt;val 也可以。 if (root == nullptr || root == p || root == q) { return root; } // 函数不是在“寻找祖先”，而是在“汇报发现”。这个算法巧妙地改变了子问题的定义 // 把一个复杂的“寻找LCA”问题，降维成了一个简单的“寻找p或q”的问题 TreeNode *lAncestor = lowestCommonAncestor(root-\u0026gt;left, p, q); TreeNode *rAncestor = lowestCommonAncestor(root-\u0026gt;right, p, q); if (lAncestor ==nullptr\u0026amp;\u0026amp;rAncestor==nullptr) return nullptr; if (lAncestor != nullptr \u0026amp;\u0026amp; rAncestor != nullptr) return root; if (lAncestor == nullptr \u0026amp;\u0026amp; rAncestor != nullptr) return rAncestor; return lAncestor; } 3. 路径问题 / 自上而下信息传递 # 这类问题与上一类相反，子问题的解决需要依赖其父节点的信息。因此，你需要通过递归函数的参数将信息自上而下地传递下去。\n核心思路： “我需要定义一个 solve(node, state) 函数，其中 state 是从根节点到我父节点为止积累的状态。在函数内部，我根据 state 和当前node 的值计算出新的状态 new_state，然后把它传递给我的子节点solve(node-\u0026gt;left, new_state)和 solve(node-\u0026gt;right, new_state)。”\n经典题目:\n112. 路径总和 # 向下传递 targetSum - node-\u0026gt;val。\n注意代码中的targetSum是值传递，也就是说并不影响函数内部操作中对其值的修改，同一层执行完res1再res2,里面传入的targetSum是相同的。\nbool hasPathSum(TreeNode *root, int targetSum) { if (root == nullptr) return 0; targetSum -= root-\u0026gt;val; if (root-\u0026gt;left == nullptr \u0026amp;\u0026amp; root-\u0026gt;right == nullptr) return targetSum == 0; bool res1 = hasPathSum(root-\u0026gt;left, targetSum); bool res2 = hasPathSum(root-\u0026gt;right, targetSum); return res1 || res2; } 129. 求根节点到叶节点数字之和 # 向下传递 currentSum * 10 + node-\u0026gt;val。\n辅助函数并没有返回值，而是把值存在了常量里面。因为返回的不是结果，所以不用只是子问题的答案，可以是最终结果 totalsum。\nclass Solution { public: int totalsum = 0; void traverse(TreeNode* node, int currentnum) { if (node == nullptr) return; int parentnum = currentnum * 10 + node-\u0026gt;val; if (node-\u0026gt;left == nullptr \u0026amp;\u0026amp; node-\u0026gt;right == nullptr) { totalsum = totalsum + parentnum; return; } traverse(node-\u0026gt;left, parentnum); traverse(node-\u0026gt;right, parentnum); } int sumNumbers(TreeNode* root) { traverse(root, 0); return totalsum; } }; 257. 二叉树的所有路径 # 向下传递当前路径的字符串 currentPath + \u0026quot;-\u0026gt;\u0026quot; + node-\u0026gt;val。\nclass Solution { public: vector\u0026lt;string\u0026gt; ans; void getpath(TreeNode* root, string path) { if (root == nullptr) { return; } path = path+to_string(root-\u0026gt;val); if (root-\u0026gt;right == nullptr \u0026amp;\u0026amp; root-\u0026gt;left == nullptr) { ans.push_back(path); return; } path = path+\u0026#34;-\u0026gt;\u0026#34;; getpath(root-\u0026gt;right, path); getpath(root-\u0026gt;left, path); } vector\u0026lt;string\u0026gt; binaryTreePaths(TreeNode* root) { getpath(root, \u0026#34;\u0026#34;); return ans; } }; 优化方案：使用回溯（Backtracking）避免浪费 还不太会，放放吧⏳\n路径用 string\u0026amp; path 传引用，递归中添加/移除（pop_back），结果直接 push 到共享 res\n无临时向量创建/合并; 字符串修改就地（O(1) 添加/移除）; 空间：O(log n) 递归栈 + O(n _ L) 最终 res; 时间：O(n _ L) 但常数小，无拷贝。 class Solution { public: void getpath(TreeNode* node, string\u0026amp; path, vector\u0026lt;string\u0026gt;\u0026amp; res) { if (node == nullptr) return; // 添加当前值（记录长度以便回溯） int prev_len = path.size(); path += to_string(node-\u0026gt;val); if (node-\u0026gt;left == nullptr \u0026amp;\u0026amp; node-\u0026gt;right == nullptr) { res.push_back(path); // 直接 push 当前路径 } else { path += \u0026#34;-\u0026gt;\u0026#34;; // 添加箭头 getpath(node-\u0026gt;left, path, res); getpath(node-\u0026gt;right, path, res); path.resize(path.size() - 2); // 移除 \u0026#34;-\u0026gt;\u0026#34; } path.resize(prev_len); // 移除当前值（回溯） } vector\u0026lt;string\u0026gt; binaryTreePaths(TreeNode* root) { vector\u0026lt;string\u0026gt; res; string path = \u0026#34;\u0026#34;; getpath(root, path, res); return res; } }; 113. 路径总和 II # 路径总和的升级版 向下传递当前路径的节点列表 vector\u0026lt;int\u0026gt; currentPath。\nclass Solution { public: vector\u0026lt;int\u0026gt; path; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; ans; void cacula(TreeNode* root, int currentnum) { if(root==nullptr){ return; } path.push_back(root-\u0026gt;val); currentnum = currentnum - root-\u0026gt;val; if (root-\u0026gt;right == nullptr \u0026amp;\u0026amp; root-\u0026gt;left == nullptr) { if (currentnum == 0) { ans.push_back(path); path.pop_back(); return; } path.pop_back(); return; } cacula(root-\u0026gt;left, currentnum); cacula(root-\u0026gt;right, currentnum); path.pop_back(); } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; pathSum(TreeNode* root, int targetSum) { if(root==nullptr) { return ans; } cacula(root, targetSum); return ans; } }; 4. 结构比较与修改 # 这类问题通常涉及两棵树，或者需要翻转、修改树的结构。\n核心思路：\n递归函数通常同时作用于两棵树的对应节点，或者在修改完当前节点的结构后，再对子节点进行递归调用。\n经典题目:\n100. 相同的树 # isSameTree(p, q) 依赖于 isSameTree(p-\u0026gt;left, q-\u0026gt;left) 和 isSameTree(p-\u0026gt;right, q-\u0026gt;right) 的结果。\nclass Solution { public: bool isSameTree(TreeNode* p, TreeNode* q) { if(p==nullptr\u0026amp;\u0026amp;q==nullptr){ return true; } if((p==nullptr\u0026amp;\u0026amp;q!=nullptr)||(p!=nullptr\u0026amp;\u0026amp;q==nullptr)||p-\u0026gt;val!=q-\u0026gt;val) { return false; } bool isLeftSame = isSameTree(p-\u0026gt;left,q-\u0026gt;left); bool isRightSame = isSameTree(p-\u0026gt;right,q-\u0026gt;right); return isLeftSame\u0026amp;\u0026amp;isRightSame; } }; 101. 对称二叉树 # 这是判断两棵树是否镜像对称的变体。递归函数 isMirror(p, q) 依赖于 isMirror(p-\u0026gt;left, q-\u0026gt;right) 和 isMirror(p-\u0026gt;right, q-\u0026gt;left)。\nbool isMirror(TreeNode* p, TreeNode* q) { if (p == nullptr \u0026amp;\u0026amp; q == nullptr) { return true; } if ((p == nullptr \u0026amp;\u0026amp; q != nullptr) || (p != nullptr \u0026amp;\u0026amp; q == nullptr) || (p-\u0026gt;val != q-\u0026gt;val)) { return false; } bool isSameOuter = isMirror(p-\u0026gt;left, q-\u0026gt;right); bool isSameInner = isMirror(p-\u0026gt;right, q-\u0026gt;left); return isSameOuter \u0026amp;\u0026amp; isSameInner; } bool isSymmetric(TreeNode* root) { if (root == nullptr) { return true; } return isMirror(root-\u0026gt;left, root-\u0026gt;right ); } 226. 翻转二叉树 # 在当前节点交换左右子节点，然后递归调用 invertTree(root-\u0026gt;left) 和 invertTree(root-\u0026gt;right)。\nclass Solution { public: TreeNode* invertTree(TreeNode* root) { if (root == nullptr) return nullptr; TreeNode* left = invertTree(root-\u0026gt;left); TreeNode* right = invertTree(root-\u0026gt;right); root-\u0026gt;right = left; root-\u0026gt;left = right; return root; } }; 总结与练习建议 # 题号 题目 核心思路 类 别 状态 94, 144, 145 二叉树遍历 访问所有节点 基础遍历 ✅ 104, 111 树的深度 从子树获取深度，组合成当前深度 分治 / 自下而上 ✅ 543 二叉树的直径 从子树获取深度，计算穿过当前节点的直径 分治 / 自下而上 ✅ 110 平衡二叉树 从子树获取“是否平衡”和“深度”两个信息 分治 / 自下而上 ✅ 236 最近公共祖先 从子树获取是否包含目标节点的信息 分治 / 自下而上 ✅ 112, 113 路径总和 将目标和减去当前值，向下传递 路径 / 自上而下 ✅ 129 求根到叶节点数字之和 将当前路径和乘以 10 加上当前值，向下传递 路径 / 自上而下 ✅ 257 二叉树的所有路径 将当前路径字符串拼接上当前值，向下传递 路径 / 自上而下 ✅ 100 相同的树 同时递归比较两棵树的对应子树 结构比较 ✅ 101 对称二叉树 同时递归比较一棵树的内外侧子树 结构比较 ✅ 226 翻转二叉树 交换当前节点的左右子节点，然后递归翻转子树 结构修改 ✅ 如何练习：\n从基础遍历开始，确保你理解前、中、后序的区别。\n主攻“分治 / 自下而上”，这是最重要的递归模式。以“最大深度”为模板，彻底理解“信任”递归调用的思想。\n然后练习“路径 / 自上而下”，理解通过参数传递状态的方法。\n最后解决结构类问题，它们通常是前面几种思想的结合或变体。\n几乎所有二叉树问题都能被归入这几类。当你遇到一个新问题时，先思考一下：“解决这个问题，我需要从子树获得什么信息，还是需要向子树传递什么信息？” 这能帮助你快速确定递归的结构。\n一些问题 # 是否需要返回值问题: # 如果叶节点或中间节点需要“向上报告”信息（如子树结果），用返回值 如果只是“遍历 + 收集到外部容器”，用 void + 共享状态\n更多练习题目见二叉树题目汇总\n","date":"15 September 2025","externalUrl":null,"permalink":"/notes/recursive_relation/","section":"Notes","summary":"","title":"递归基础及题目（Recursive Relation）","type":"notes"},{"content":"","date":"8 September 2025","externalUrl":null,"permalink":"/tags/conda/","section":"Tags","summary":"","title":"Conda","type":"tags"},{"content":"https://docs.conda.io/projects/conda/en/latest/user-guide/getting-started.html\n创建环境 # 创建一个新环境\nconda create -n \u0026lt;env-name\u0026gt; 创建环境并且下载指定包\nconda create -n myenvironment python numpy pandas conda create -n myenv scipy=0.17.3 //特定库版本 创建环境指定特定pyhton版本 conda create -n myenv python=3.9 conda create -n myenv python=3.9 特定pyhton版本和多个库 conda create -n myenv python=3.9 scipy=0.17.3 astroid babel\n查看所有环境 # conda info --envs 例如： conda environments: base /home/username/Anaconda3 myenvironment * /home/username/Anaconda3/envs/myenvironment 当前环境带*\n改变当前环境为默认的一个\nconda activate 下载库 # # via environment activation conda activate myenvironment conda install matplotlib # via command line option conda install --name myenvironment matplotlib If a package you want is located in another channel, such as conda-forge, you can manually specify the channel when installing the package:\nconda install conda-forge::numpy 更新Conda # 查看Conda版本\nconda --version 更新到最新版本\nconda update conda ","date":"8 September 2025","externalUrl":null,"permalink":"/posts/conda_start/","section":"Posts","summary":"Conda使用","title":"Conda Start","type":"posts"},{"content":" 莫里斯遍历 - 实例走查 # 我们将使用下面的树来进行中序遍历。遍历的结果应该是 [1, 2, 3, 4, 6]。\n初始状态:\ncurrent 指向根节点 4。 result (结果数组) 为 []。 4 \u0026lt;\u0026ndash; current / \\ 2 6 /\\ 1 3\n第 1 步 # current = 4\n判断: current (4) 有左孩子 2。\n动作:\n找到 current (4) 的左子树 (2 为根) 的最右节点。这个节点是 3。 3 的右指针是 nullptr。 建立线索: 将 3 的右指针指向 current (4)。 current 向左移动：current = current-\u0026gt;left (移向 2)。 树的状态: 4 / \\ 2 6 / 1 3 \u0026ndash;+ ^ | |___| (线索指向 4)\nresult: []\n第 2 步 # current = 2\n判断: current (2) 有左孩子 1。\n动作:\n找到 current (2) 的左子树 (1 为根) 的最右节点。这个节点就是 1 本身。 1 的右指针是 nullptr。 建立线索: 将 1 的右指针指向 current (2)。 current 向左移动：current = current-\u0026gt;left (移向 1)。 树的状态: 4 / 2 6 /\n1 3 \u0026ndash;+ ^ \\ | | +\u0026mdash;-|\u0026ndash;(线索指向 2) |_______| (线索指向 4)\nresult: [] 第 3 步 # current = 1\n判断: current (1) 没有左孩子。\n动作:\n访问 1。 current 向右移动：current = current-\u0026gt;right (根据我们建立的线索，它会移向 2)。 result: [1]\n第 4 步 # current = 2\n判断: current (2) 有左孩子 1。\n动作:\n再次找到 current (2) 的左子树的最右节点，还是 1。 这一次，我们发现 1 的右指针指向 current (2)，说明我们已经处理完 current 的左子树了。 访问 2。 断开线索: 将 1 的右指针恢复为 nullptr。 current 向右移动：current = current-\u0026gt;right (移向 3)。 树的状态 (1-\u0026gt;2 的线索已断开): 4 / \\ 2 6 / 1 3 \u0026ndash;+ ^ | |___| (线索指向 4)\nresult: [1, 2]\n第 5 步 # current = 3\n判断: current (3) 没有左孩子。\n动作:\n访问 3。 current 向右移动：current = current-\u0026gt;right (根据我们建立的线索，它会移向 4)。 result: [1, 2, 3]\n第 6 步 # current = 4\n判断: current (4) 有左孩子 2。\n动作:\n再次找到 current (4) 的左子树的最右节点，还是 3。 我们发现 3 的右指针指向 current (4)，说明我们已经处理完 current 的左子树了。 访问 4。 断开线索: 将 3 的右指针恢复为 nullptr。 current 向右移动：current = current-\u0026gt;right (移向 6)。 树的状态 (完全恢复): 4 / \\ 2 6 / 1 3\nresult: [1, 2, 3, 4]\n第 7 步 # current = 6\n判断: current (6) 没有左孩子。\n动作:\n访问 6。 current 向右移动：current = current-\u0026gt;right (移向 nullptr)。 result: [1, 2, 3, 4, 6]\n结束 # current = nullptr 判断: 循环结束。 最终，我们得到了正确的中序遍历结果 [1, 2, 3, 4, 6]，并且树的结构也完全恢复到了初始状态。\n希望这个一步步的分解能帮助你理解莫里斯遍历的工作流程！\n","date":"3 September 2025","externalUrl":null,"permalink":"/notes/morris_traversal/","section":"Notes","summary":"","title":"Morris Traversal","type":"notes"},{"content":"步骤 1: 在 GitHub 上创建新的远程仓库 步骤 2: 在本地电脑上操作\n# 打开 Git Bash进入你的项目文件夹 cd ~/Desktop/my-first-project # 初始化 Git 仓库: git init #添加所有文件到暂存区: git add . # 提交文件到本地仓库: git commit -m \u0026#34;Initial commit\u0026#34; #重命名主分支为 main git branch -m main # 关联本地仓库和远程仓库: git remote add origin https://github.com/YourUsername/YourProjectName.git # 把下面的 URL 换成你自己的仓库 URL # 推送代码到 GitHub: git push -u origin main ","date":"2 September 2025","externalUrl":null,"permalink":"/posts/a_folder_to_git/","section":"Posts","summary":"本地文件夹上传至GitHub","title":"A Folder to Git","type":"posts"},{"content":"创建项目文件夹\n打开命令行工具（比如 CMD、PowerShell 或者 Windows Terminal），然后进入存放所有代码的目录（例如 D:\\projects）。\n# 1. 进入项目的父目录(请根据实际情况修改 \u0026#34;D:\\projects\u0026#34;) cd D:\\projects 2. 创建新文件夹作为根目录 mkdir my_new_project 3. 进入这个新创建的文件夹 cd my_new_project 创建虚拟环境\n# 确保在项目根目录下 (D:\\projects\\my_new_project) # -m venv 的意思是 \u0026#34;以模块(module)方式运行 venv\u0026#34; # 最后的 \u0026#34;venv\u0026#34; 是给虚拟环境文件夹取的名字 python -m venv venv # 执行完毕后，会发现项目文件夹里多出了一个名为 venv 的子文件夹。这里面包含了独立的 Python 解释器和未来将要安装的库。 激活虚拟环境\n# 在 Windows PowerShell 中，运行以下命令 .\\venv\\Scripts\\activate 激活成功后，会看到命令行提示符的前面多了一个 (venv) 的标记，像这样： (venv) PS D:\\projects\\my_new_project\u0026gt; 这个 (venv) 标志非常重要，它告诉你当前终端已经处于激活的虚拟环境中。所有后续的 pip 安装和 python 命令都将只在这个环境内生效。\n# 在 VS Code 中打开项目,确保还在项目根目录下 (有 (venv) 标志),这个命令会用 VS Code 打开当前文件夹 code . 配置 VS Code 解释器\n1.当用 VS Code 打开带有 venv 文件夹的项目时，VS Code 通常会在右下角弹出一个提示：We noticed a new environment has been created. Do you want to select it for the workspace folder? (我们发现了一个新环境，您要为工作区选择它吗？)。\n请务必点击 Yes。\n2.如果 VS Code 没有自动提示，可以手动选择：\n按下 Ctrl+Shift+P 打开命令面板。\n输入并选择 Python: Select Interpreter (Python: 选择解释器)。\n在列表中，选择那个带有 (\u0026lsquo;venv\u0026rsquo;: venv) 标志或者路径中包含 .\\venv\\Scripts\\python.exe 的选项。\n安装项目所需的库\n现在，可以在 VS Code 的集成终端中（确保终端前面有 (venv) 标志）安装任何需要的第三方库了。\n完整的、专业的开发流程\n在项目开始时就创建.gitignore 文件，并加入 venv/\n在虚拟环境中安装项目所需的库（例如pip install pandas）\n每当安装或更新了重要的库之后，就更新 requirements.txt文件： pip freeze \u0026gt; requirements.txt\n将源代码、.gitignore 和更新后的 requirements.txt 一起提交到GitHub。\ngit add . git commit -m \u0026#34;Add new feature and update dependencies\u0026#34; git push 拿到项目后,只需要执行以下几步\n克隆仓库 git clone \u0026lt;your_repo_url\u0026gt; cd \u0026lt;your_repo_name\u0026gt; 创建并激活他们自己的venv python -m venv venv 在Windows上: .\\venv\\Scripts\\activate 在macOS/Linux上: source venv/bin/activate 根据依赖列表，一键安装所有库 pip install -r requirements.txt ","date":"11 August 2025","externalUrl":null,"permalink":"/posts/create_new_project/","section":"Posts","summary":"带虚拟环境的 Python 项目","title":"Create New Project","type":"posts"},{"content":"","date":"11 August 2025","externalUrl":null,"permalink":"/tags/python/","section":"Tags","summary":"","title":"Python","type":"tags"},{"content":" 状态 图标 说明 完成 ✅ 任务已完成 进行中 🔄 正在处理 待处理 ⏳ 等待开始 错误 ❌ 出现问题 警告 ⚠️ 需要注意 未完成的任务 已完成的任务 另一个未完成的任务 特性 React Vue.js Angular 评分 学习曲线 中等 简单 复杂 Vue ⭐⭐⭐ 性能表现 优秀 优秀 良好 平分 ⭐⭐⭐ 生态系统 丰富 成长中 完整 React ⭐⭐⭐ 企业支持 Facebook 社区 Google Angular ⭐⭐⭐ 使用 Ctrl+Alt+Del 重启电脑\ngraph LR A[方形] --\u0026gt;B(圆角) B --\u0026gt; C{条件a} C --\u0026gt;|a=1| D[结果1] C --\u0026gt;|a=2| E[结果2] F[横向流程图] graph TD A[方形] --\u0026gt; B(圆角) B --\u0026gt; C{条件a} C --\u0026gt; |a=1| D[结果1] C --\u0026gt; |a=2| E[结果2] F[竖向流程图] st=\u0026gt;start: 开始框 op=\u0026gt;operation: 处理框 cond=\u0026gt;condition: 判断框(是或否?) sub1=\u0026gt;subroutine: 子流程 io=\u0026gt;inputoutput: 输入输出框 e=\u0026gt;end: 结束框 st(right)-\u0026gt;op(right)-\u0026gt;cond cond(yes)-\u0026gt;io(bottom)-\u0026gt;e cond(no)-\u0026gt;sub1(right)-\u0026gt;op 文本中的变量 $x = 5$ 和函数 $f(x) = x^2 + 2x + 1$。\n$$ \\begin{align} f(x) \u0026= ax^2 + bx + c \\\\ f'(x) \u0026= 2ax + b \\\\ f''(x) \u0026= 2a \\end{align} $$$$E = mc^2$$$$\\int_{-\\infty}^{\\infty} e^{-x^2} dx = \\sqrt{\\pi}$$ 张三 | 前端开发工程师 # 📞 联系方式 # 邮箱: zhangsan@email.com 电话: 138-0000-0000 GitHub: github.com/zhangsan LinkedIn: linkedin.com/in/zhangsan 地址: 上海市浦东新区 🎯 职业目标 # 具有 3 年前端开发经验的工程师，专注于 React 生态系统和现代化 Web 应用开发。寻求在创新型公司中担任高级前端开发职位，希望参与大型项目的架构设计和团队协作。\n💼 工作经验 # 高级前端开发工程师 | ABC 科技有限公司 # 2022.03 - 至今\n负责公司核心产品的前端开发，用户量达 100 万+ 使用 React、TypeScript 构建可维护的大型单页应用 与产品和设计团队协作，将设计稿转化为高质量的用户界面 建立前端组件库，提升团队开发效率 30% 技术栈: React, TypeScript, Redux, Webpack, Jest 前端开发工程师 | XYZ 互联网公司 # 2021.06 - 2022.02\n参与电商平台的前端开发和维护工作 优化页面性能，首屏加载时间减少 40% 负责移动端 H5 页面开发，适配多种设备 技术栈: Vue.js, JavaScript, SCSS, Element UI 🛠️ 技能清单 # 编程语言 # 熟练: JavaScript, TypeScript, HTML5, CSS3 了解: Python, Java, Go 前端框架 # React 生态: React, Redux, React Router, Next.js Vue 生态: Vue.js, Vuex, Vue Router, Nuxt.js 其他: Angular 基础 开发工具 # 版本控制 # Git, GitHub, GitLab 构建工具 # Webpack, Vite, Rollup Babel, PostCSS 测试工具 # Jest, Cypress, Testing Library 📱 联系方式 # 💼 工作经验 # 🎓 教育背景 # 🛠️ 技能清单 # 🚀 项目经历 # 🏆 获奖经历 # 📊 技能评估 # 技能类别 具体技能 熟练程度 前端框架 React ⭐⭐⭐⭐⭐ 前端框架 Vue.js ⭐⭐⭐⭐ 编程语言 TypeScript ⭐⭐⭐⭐ 编程语言 JavaScript ⭐⭐⭐⭐⭐ 🔗 在线作品 # ","date":"9 August 2025","externalUrl":null,"permalink":"/posts/learnmd/","section":"Posts","summary":"","title":"Publishing_process 博客发布流程","type":"posts"},{"content":"1.创建一篇新文章 打开Git Bash 终端，进入根目录d:/Blog\nhugo new content posts/hello-world.md\n告诉Hugo，在 content/posts/ 目录下，创建一个名为 hello-world.md 的新文章。\n2.编写文章内容\n打开VS Code，在 hello-world.md里面写内容 将draft：true改为draft：false 3.在本地预览效果\n回到Git Bash终端，运行： hugo server\n终端会启动一个本地服务器，并显示网址 http://localhost:1313/,打开网址浏览即可 预览完毕后，回到终端，按 Ctrl + C 组合键，停止本地服务器。 4.提交并推送到GitHub (自动发布)\n添加更改到暂存区 git add .\n提交更改到本地仓库 (创建一个新的提交记录) git commit -m \u0026ldquo;feat: Add my first post \u0026lsquo;Hello World\u0026rsquo;\u0026rdquo;\nfeat: 是一种规范的提交信息前缀，意思是“增加新功能”，这里指增加了新文章。\n写了一篇新文章？用 feat。\n修改了一篇文章的内容或错别字？用 docs。\n修正了一个导致网站显示不正常的Bug？用 fix。\n更新了 .gitignore 或者 deploy.yml？用 chore。\n推送到GitHub (这是触发自动部署的扳机) git push origin main\n5.检查线上部署\n打开浏览器，进入您之前创建的源码仓 (Blog-Source) 的GitHub页面。 点击页面上方的 “Actions” 选项卡。 您会看到一个新的工作流（Workflow）正在运行，它前面会有一个黄色的小圆圈。这就是GitHub在后台帮您生成和部署网站。 等待1-2分钟，当黄色圆圈变成绿色的对勾 (✓) 时，就代表您的网站已经部署成功了。 现在，请在浏览器中访问您的线上博客地址： https://\u0026lt;您的GitHub用户名\u0026gt;.github.io\n","date":"9 August 2025","externalUrl":null,"permalink":"/posts/publishing_process/","section":"Posts","summary":"","title":"Publishing_process 博客发布流程","type":"posts"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]